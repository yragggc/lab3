diff -ruN linux-02.01.03.11-org/arch/arm/configs/omap3_devkit8000_defconfig linux-02.01.03.11-new/arch/arm/configs/omap3_devkit8000_defconfig
--- linux-02.01.03.11-org/arch/arm/configs/omap3_devkit8000_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ linux-02.01.03.11-new/arch/arm/configs/omap3_devkit8000_defconfig	2010-01-21 14:08:17.000000000 +0800
@@ -0,0 +1,1815 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28-rc9-omap1
+# Sat Jan  9 16:33:00 2010
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_USER_SCHED=y
+# CONFIG_CGROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_CLASSIC_RCU=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+CONFIG_ARCH_OMAP=y
+# CONFIG_ARCH_MSM is not set
+
+#
+# TI OMAP Implementations
+#
+CONFIG_ARCH_OMAP_OTG=y
+# CONFIG_ARCH_OMAP1 is not set
+# CONFIG_ARCH_OMAP2 is not set
+CONFIG_ARCH_OMAP3=y
+
+#
+# OMAP Feature Selections
+#
+# CONFIG_OMAP_DEBUG_POWERDOMAIN is not set
+# CONFIG_OMAP_DEBUG_CLOCKDOMAIN is not set
+# CONFIG_OMAP_SMARTREFLEX is not set
+# CONFIG_OMAP_RESET_CLOCKS is not set
+CONFIG_OMAP_BOOT_TAG=y
+CONFIG_OMAP_BOOT_REASON=y
+# CONFIG_OMAP_COMPONENT_VERSION is not set
+# CONFIG_OMAP_GPIO_SWITCH is not set
+# CONFIG_OMAP_MUX is not set
+CONFIG_OMAP_MCBSP=y
+# CONFIG_OMAP_MMU_FWK is not set
+# CONFIG_OMAP_MBOX_FWK is not set
+# CONFIG_OMAP_MPU_TIMER is not set
+CONFIG_OMAP_32K_TIMER=y
+CONFIG_OMAP_32K_TIMER_HZ=128
+CONFIG_OMAP_DM_TIMER=y
+# CONFIG_OMAP_LL_DEBUG_UART1 is not set
+# CONFIG_OMAP_LL_DEBUG_UART2 is not set
+CONFIG_OMAP_LL_DEBUG_UART3=y
+CONFIG_OMAP2_DSS=y
+# CONFIG_OMAP2_DSS_DEBUG_SUPPORT is not set
+# CONFIG_OMAP2_DSS_RFBI is not set
+CONFIG_OMAP2_DSS_VENC=y
+# CONFIG_OMAP2_DSS_SDI is not set
+# CONFIG_OMAP2_DSS_DSI is not set
+# CONFIG_OMAP2_DSS_FAKE_VSYNC is not set
+#CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK=4
+CONFIG_ARCH_OMAP34XX=y
+CONFIG_ARCH_OMAP3430=y
+
+#
+# OMAP Board Type
+#
+# CONFIG_MACH_OMAP_LDP is not set
+# CONFIG_MACH_OMAP_3430SDP is not set
+# CONFIG_MACH_OMAP3EVM is not set
+# CONFIG_MACH_OMAP3_BEAGLE is not set
+# CONFIG_MACH_OMAP3_DEVKIT9000 is not set
+CONFIG_MACH_OMAP3_DEVKIT8000=y
+CONFIG_MACH_OMAP3_DevKit8000_MMDC=y
+# CONFIG_MACH_OMAP3_SBC8110 is not set
+# CONFIG_MACH_OVERO is not set
+# CONFIG_MACH_OMAP3_PANDORA is not set
+CONFIG_OMAP_TICK_GPTIMER=12
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_IFAR=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_HAS_TLS_REG=y
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=128
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+# CONFIG_LEDS is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/nfs nfsroot=192.168.0.1:/home/user/buildroot ip=192.168.0.2:192.168.0.1:192.168.0.1:255.255.255.0:tgt:eth0:off rw console=ttyS2,115200n8"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_FREQ is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+# CONFIG_NEON is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_SUSPEND is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_OMAP2=y
+# CONFIG_MTD_NAND_OMAP_PREFETCH is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=40960
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+CONFIG_DM9000=y
+CONFIG_DM9000_DEBUGLEVEL=4
+# CONFIG_DM9000_FORCE_SIMPLE_PHY_POLL is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_SMC911X is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPPOE=y
+CONFIG_PPPOL2TP=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+CONFIG_KEYBOARD_TWL4030=y
+# CONFIG_KEYBOARD_LM8323 is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=y
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC210X is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=32
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+CONFIG_SERIAL_8250_DETECT_IRQ=y
+CONFIG_SERIAL_8250_RSA=y
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_OMAP=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_AT24 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_MADC is not set
+# CONFIG_TWL4030_PWRBUTTON is not set
+# CONFIG_TWL4030_POWEROFF is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_LP5521 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+CONFIG_SPI_OMAP24XX=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_TSC210X is not set
+# CONFIG_SPI_TSC2301 is not set
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+# CONFIG_GPIO_SYSFS is not set
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+CONFIG_GPIO_TWL4030=y
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+CONFIG_TWL4030_CORE=y
+# CONFIG_TWL4030_POWER is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_COMMON=y
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=y
+
+#
+# Multimedia drivers
+#
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=y
+# CONFIG_MEDIA_TUNER_CUSTOMIZE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=y
+CONFIG_MEDIA_TUNER_TDA8290=y
+CONFIG_MEDIA_TUNER_TDA9887=y
+CONFIG_MEDIA_TUNER_TEA5761=y
+CONFIG_MEDIA_TUNER_TEA5767=y
+CONFIG_MEDIA_TUNER_MT20XX=y
+CONFIG_MEDIA_TUNER_XC2028=y
+CONFIG_MEDIA_TUNER_XC5000=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_SG=y
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TDA9875 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_TCM825X is not set
+# CONFIG_VIDEO_OV3640 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA7111 is not set
+# CONFIG_VIDEO_SAA7114 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP5150 is not set
+CONFIG_VIDEO_TVP514X=y
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+CONFIG_VIDEO_OMAP3_ISP=y
+# CONFIG_VIDEO_OMAP34XX_ISP_PREVIEWER is not set
+# CONFIG_VIDEO_OMAP34XX_ISP_RESIZER is not set
+CONFIG_VIDEO_OMAP3_CAM=y
+CONFIG_VIDEO_OMAP3=y
+CONFIG_VIDEO_OMAP_VIDEOLIB=y
+CONFIG_VIDEO_OMAP_VIDEOOUT=y
+# CONFIG_VID1_TV_MANAGER is not set
+CONFIG_VID1_LCD_MANAGER=y
+# CONFIG_VID2_TV_MANAGER is not set
+CONFIG_VID2_LCD_MANAGER=y
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_V4L_USB_DRIVERS is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_USB_DSBR is not set
+# CONFIG_USB_SI470X is not set
+# CONFIG_USB_MR800 is not set
+CONFIG_DAB=y
+# CONFIG_USB_DABUSB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+CONFIG_FB_OMAP_CONSISTENT_DMA_SIZE=12
+CONFIG_FB_OMAP2=y
+# CONFIG_FB_OMAP2_DEBUG is not set
+# CONFIG_FB_OMAP2_FORCE_AUTO_UPDATE is not set
+CONFIG_FB_OMAP2_NUM_FBS=1
+
+#
+# OMAP2/3 Display Device Drivers
+#
+CONFIG_PANEL_GENERIC=y
+CONFIG_RES_480P=y
+# CONFIG_RES_720P is not set
+# CONFIG_PANEL_N800 is not set
+# CONFIG_CTRL_BLIZZARD is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_CORGI is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_OMAP_SOC=y
+CONFIG_SND_OMAP_SOC_MCBSP=y
+CONFIG_SND_OMAP_SOC_OMAP3_DEVKIT8000=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_TWL4030=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+CONFIG_HIDRAW=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_COMPAT=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_BRIGHT=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DELL=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_THRUSTMASTER_FF is not set
+# CONFIG_ZEROPLUS_FF is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_OMAP_EHCI_PHY_MODE=y
+# CONFIG_OMAP_EHCI_TLL_MODE is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_SOC=y
+
+#
+# OMAP 343x high speed USB support
+#
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_PERIPHERAL is not set
+CONFIG_USB_MUSB_OTG=y
+CONFIG_USB_GADGET_MUSB_HDRC=y
+CONFIG_USB_MUSB_HDRC_HCD=y
+# CONFIG_MUSB_PIO_ONLY is not set
+CONFIG_USB_INVENTRA_DMA=y
+# CONFIG_USB_TI_CPPI_DMA is not set
+# CONFIG_USB_MUSB_DEBUG is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+# CONFIG_USB_EZUSB is not set
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP2101 is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+CONFIG_USB_ETH=y
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_ISP1301_OMAP is not set
+CONFIG_TWL4030_USB=y
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_OMAP_HS=y
+# CONFIG_MMC_SPI is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_OMAP_DEBUG is not set
+# CONFIG_LEDS_OMAP is not set
+# CONFIG_LEDS_OMAP_PWM is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_PCA955X is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+CONFIG_RTC_DRV_TWL4030=y
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# CBUS support
+#
+# CONFIG_CBUS is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_XATTR is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+# CONFIG_QUOTA_NETLINK_INTERFACE is not set
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=y
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_BOOT_TRACER is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_ERRORS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+CONFIG_CRYPTO_PCBC=m
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff -ruN linux-02.01.03.11-org/arch/arm/mach-omap2/board-omap3devkit8000.c linux-02.01.03.11-new/arch/arm/mach-omap2/board-omap3devkit8000.c
--- linux-02.01.03.11-org/arch/arm/mach-omap2/board-omap3devkit8000.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-02.01.03.11-new/arch/arm/mach-omap2/board-omap3devkit8000.c	2010-01-18 21:13:26.000000000 +0800
@@ -0,0 +1,669 @@
+/*
+ * linux/arch/arm/mach-omap2/board-omap3_devkit8000.c
+ *
+ * Copyright (C) 2009 Embest
+ *
+ * Modified from mach-omap2/board-omap3beagle.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/leds.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/gpio_keys.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+
+#include <linux/regulator/machine.h>
+
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+
+#include <mach/board.h>
+#include <mach/usb-musb.h>
+#include <mach/usb-ehci.h>
+#include <mach/common.h>
+#include <mach/gpmc.h>
+#include <mach/nand.h>
+#include <mach/mux.h>
+
+#include "twl4030-generic-scripts.h"
+#include "mmc-twl4030.h"
+#include "pm.h"
+#include "omap3-opp.h"
+#include <mach/keypad.h>
+#include <mach/mcspi.h>
+#include <mach/display.h>
+#include <linux/dm9000.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/ads7846.h>
+#include <linux/w1-gpio.h>
+
+#define GPMC_CS0_BASE  0x60
+#define GPMC_CS_SIZE   0x30
+#define TWL4030_VAUX2_1P8V 0x5
+#define ENABLE_VAUX2_DEV_GRP 0x20
+
+
+#define NAND_BLOCK_SIZE		SZ_128K
+
+static struct mtd_partition omap3_devkit8000_nand_partitions[] = {
+	/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name		= "X-Loader",
+		.offset		= 0,
+		.size		= 4 * NAND_BLOCK_SIZE,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+	{
+		.name		= "U-Boot",
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x80000 */
+		.size		= 15 * NAND_BLOCK_SIZE,
+		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
+	},
+	{
+		.name		= "U-Boot Env",
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x260000 */
+		.size		= 1 * NAND_BLOCK_SIZE,
+	},
+	{
+		.name		= "Kernel",
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x280000 */
+		.size		= 32 * NAND_BLOCK_SIZE,
+	},
+	{
+		.name		= "File System",
+		.offset		= MTDPART_OFS_APPEND,	/* Offset = 0x680000 */
+		.size		= MTDPART_SIZ_FULL,
+	},
+};
+
+static struct omap_nand_platform_data omap3_devkit8000_nand_data = {
+	.options	= NAND_BUSWIDTH_16,
+	.parts		= omap3_devkit8000_nand_partitions,
+	.nr_parts	= ARRAY_SIZE(omap3_devkit8000_nand_partitions),
+	.dma_channel	= -1,		/* disable DMA in OMAP NAND driver */
+	.nand_setup	= NULL,
+	.dev_ready	= NULL,
+};
+
+static struct resource omap3_devkit8000_nand_resource = {
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device omap3_devkit8000_nand_device = {
+	.name		= "omap2-nand",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &omap3_devkit8000_nand_data,
+	},
+	.num_resources	= 1,
+	.resource	= &omap3_devkit8000_nand_resource,
+};
+
+#include "sdram-micron-mt46h32m32lf-6.h"
+
+static struct omap_uart_config omap3_devkit8000_uart_config __initdata = {
+	.enabled_uarts	= ((1 << 0) | (1 << 1) | (1 << 2)),
+};
+
+static struct twl4030_usb_data devkit8000_usb_data = {
+	.usb_mode	= T2_USB_MODE_ULPI,
+};
+
+static struct twl4030_hsmmc_info mmc[] = {
+	{
+		.mmc		= 1,
+		.wires		= 8,
+		.gpio_wp	= 29,
+	},
+	{}	/* Terminator */
+};
+
+static struct gpio_led gpio_leds[];
+
+static int devkit8000_twl_gpio_setup(struct device *dev,
+		unsigned gpio, unsigned ngpio)
+{
+	/* gpio + 0 is "mmc0_cd" (input/IRQ) */
+	omap_cfg_reg(AH8_34XX_GPIO29);
+	mmc[0].gpio_cd = gpio + 0;
+	twl4030_mmc_init(mmc);
+
+	/* REVISIT: need ehci-omap hooks for external VBUS
+	 * power switch and overcurrent detect
+	 */
+
+	gpio_request(gpio + 1, "EHCI_nOC");
+	gpio_direction_input(gpio + 1);
+
+	/* TWL4030_GPIO_MAX + 0 == ledA, EHCI nEN_USB_PWR (out, active low) */
+	gpio_request(gpio + TWL4030_GPIO_MAX, "nEN_USB_PWR");
+	gpio_direction_output(gpio + TWL4030_GPIO_MAX, 1);
+
+	/* TWL4030_GPIO_MAX + 1 == ledB, PMU_STAT (out, active low LED) */
+	gpio_leds[2].gpio = gpio + TWL4030_GPIO_MAX + 1;
+
+	return 0;
+}
+
+static struct twl4030_gpio_platform_data devkit8000_gpio_data = {
+	.gpio_base	= OMAP_MAX_GPIO_LINES,
+	.irq_base	= TWL4030_GPIO_IRQ_BASE,
+	.irq_end	= TWL4030_GPIO_IRQ_END,
+	.use_leds	= true,
+	.pullups	= BIT(1),
+	.pulldowns	= BIT(2) | BIT(6) | BIT(7) | BIT(8) | BIT(13)
+				| BIT(15) | BIT(16) | BIT(17),
+	.setup		= devkit8000_twl_gpio_setup,
+};
+
+/* VMMC1 for MMC1 pins CMD, CLK, DAT0..DAT3 (20 mA, plus card == max 220 mA) */
+static struct regulator_init_data devkit8000_vmmc1 = {
+	.constraints = {
+		.valid_modes_mask = REGULATOR_MODE_NORMAL
+				| REGULATOR_MODE_STANDBY,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE
+				| REGULATOR_CHANGE_MODE
+				| REGULATOR_CHANGE_STATUS,
+	},
+};
+
+/* VSIM for MMC1 pins DAT4..DAT7 (2 mA, plus card == max 50 mA) */
+static struct regulator_init_data devkit8000_vsim = {
+	.constraints = {
+		.valid_modes_mask = REGULATOR_MODE_NORMAL
+				| REGULATOR_MODE_STANDBY,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE
+				| REGULATOR_CHANGE_MODE
+				| REGULATOR_CHANGE_STATUS,
+	},
+};
+
+/* VDAC for DSS driving S-Video (8 mA unloaded, max 65 mA) */
+static struct regulator_init_data devkit8000_vdac = {
+	.constraints = {
+		.min_uV			= 1800000,
+		.max_uV			= 1800000,
+		.valid_modes_mask	= REGULATOR_MODE_NORMAL
+					| REGULATOR_MODE_STANDBY,
+		.valid_ops_mask		= REGULATOR_CHANGE_MODE
+					| REGULATOR_CHANGE_STATUS,
+	},
+};
+
+static int devkit8000_keymap[] = {
+        KEY(0, 0, KEY_1),
+        KEY(0, 1, KEY_2),
+        KEY(0, 2, KEY_3),
+        KEY(0, 3, KEY_F1),
+        KEY(1, 0, KEY_4),
+        KEY(1, 1, KEY_5),
+        KEY(1, 2, KEY_6),
+        KEY(1, 3, KEY_F2),
+        KEY(2, 0, KEY_7),
+        KEY(2, 1, KEY_8),
+        KEY(2, 2, KEY_9),
+        KEY(2, 3, KEY_ENTER),
+        KEY(3, 0, KEY_F3),
+        KEY(3, 1, KEY_0),
+        KEY(3, 2, KEY_F4),
+        KEY(3, 3, KEY_BACKSPACE)
+};
+
+static struct twl4030_keypad_data devkit8000_kp_data = {
+        .rows           = 4,
+        .cols           = 4,
+        .keymap         = devkit8000_keymap,
+        .keymapsize     = ARRAY_SIZE(devkit8000_keymap),
+        .rep            = 1,
+};
+
+static struct twl4030_platform_data devkit8000_twldata = {
+	.irq_base	= TWL4030_IRQ_BASE,
+	.irq_end	= TWL4030_IRQ_END,
+
+	/* platform_data for children goes here */
+	.usb		= &devkit8000_usb_data,
+	.gpio		= &devkit8000_gpio_data,
+	.power		= GENERIC3430_T2SCRIPTS_DATA,
+	.vmmc1		= &devkit8000_vmmc1,
+	.vsim		= &devkit8000_vsim,
+	.vdac		= &devkit8000_vdac,
+	.keypad		= &devkit8000_kp_data,
+};
+
+static struct i2c_board_info __initdata devkit8000_i2c_boardinfo[] = {
+	{
+		I2C_BOARD_INFO("twl4030", 0x48),
+		.flags = I2C_CLIENT_WAKE,
+		.irq = INT_34XX_SYS_NIRQ,
+		.platform_data = &devkit8000_twldata,
+	},
+};
+
+static int __init omap3_devkit8000_i2c_init(void)
+{
+	omap_register_i2c_bus(1, 2600, devkit8000_i2c_boardinfo,
+			ARRAY_SIZE(devkit8000_i2c_boardinfo));
+//#ifdef CONFIG_I2C2_OMAP_BEAGLE
+	omap_register_i2c_bus(2, 400, NULL, 0);
+//#endif
+	omap_register_i2c_bus(3, 400, NULL, 0);
+	return 0;
+}
+
+#define OMAP_DM9000_GPIO_IRQ    25
+
+static void __init omap_dm9000_init(void)
+{
+        if (gpio_request(OMAP_DM9000_GPIO_IRQ, "dm9000 irq") < 0) {
+                printk(KERN_ERR "Failed to request GPIO%d for dm9000 IRQ\n",
+                        OMAP_DM9000_GPIO_IRQ);
+                return;
+        }
+
+        gpio_direction_input(OMAP_DM9000_GPIO_IRQ);
+}
+
+#define OMAP3_BEAGLE_TS_GPIO       27
+
+static void ads7846_dev_init(void)
+{
+	if (gpio_request(OMAP3_BEAGLE_TS_GPIO, "ADS7846 pendown") < 0)
+		printk(KERN_ERR "can't get ads7846 pen down GPIO\n");
+
+	gpio_direction_input(OMAP3_BEAGLE_TS_GPIO);
+
+	omap_set_gpio_debounce(OMAP3_BEAGLE_TS_GPIO, 1);
+	omap_set_gpio_debounce_time(OMAP3_BEAGLE_TS_GPIO, 0xa);
+}
+
+static int ads7846_get_pendown_state(void)
+{
+	return !gpio_get_value(OMAP3_BEAGLE_TS_GPIO);
+}
+
+struct ads7846_platform_data ads7846_conf = {
+	.x_max                  = 0x0fff,
+	.y_max                  = 0x0fff,
+//	.x_plate_ohms           = 180,
+//	.pressure_max           = 255,
+	.debounce_max           = 10,
+	.debounce_tol           = 5,
+	.debounce_rep           = 1,
+	.get_pendown_state	= ads7846_get_pendown_state,
+	.keep_vref_on		= 1,
+	.settle_delay_usecs     = 150,
+};
+
+static struct omap2_mcspi_device_config ads7846_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel	= 1,  /* 0: slave, 1: master */
+};
+
+struct spi_board_info omap3_devkit8000_spi_board_info[] = {
+	[0] = {
+		.modalias		= "ads7846",
+		.bus_num		= 2,
+		.chip_select		= 0,
+		.max_speed_hz		= 1500000,
+		.controller_data	= &ads7846_mcspi_config,
+		.irq			= OMAP_GPIO_IRQ(OMAP3_BEAGLE_TS_GPIO),
+		.platform_data		= &ads7846_conf,
+	},
+};
+
+static void __init omap3_devkit8000_init_irq(void)
+{
+	omap2_init_common_hw(mt46h32m32lf6_sdrc_params, omap3_mpu_rate_table,omap3_dsp_rate_table, omap3_l3_rate_table);
+	omap_init_irq();
+	omap_gpio_init();
+	omap_dm9000_init();
+	ads7846_dev_init();
+}
+
+#ifdef CONFIG_OMAP2_DSS
+#ifdef CONFIG_FB_OMAP2
+static struct resource omap3evm_vout_resource[3 - CONFIG_FB_OMAP2_NUM_FBS] = {
+};
+#else /* CONFIG_FB_OMAP2 */
+static struct resource omap3evm_vout_resource[2] = {
+};
+#endif /* CONFIG_FB_OMAP2 */
+static struct platform_device omap3evm_vout_device = {
+        .name                   = "omap_vout",
+        .num_resources  = ARRAY_SIZE(omap3evm_vout_resource),
+        .resource               = &omap3evm_vout_resource[0],
+        .id             = -1,
+};
+
+static int lcd_enabled;
+static int dvi_enabled;
+
+static int omap3_evm_panel_enable_lcd(struct omap_display *display)
+{
+        if (dvi_enabled) {
+                return -EINVAL;
+        }
+
+        twl4030_i2c_write_u8(TWL4030_MODULE_GPIO, 0x80, REG_GPIODATAOUT1);
+        twl4030_i2c_write_u8(TWL4030_MODULE_LED, 0x0, 0x0);
+
+        lcd_enabled = 1;
+        return 0;
+}
+
+static void omap3_evm_panel_disable_lcd(struct omap_display *display)
+{
+        twl4030_i2c_write_u8(TWL4030_MODULE_GPIO, 0x00, REG_GPIODATAOUT1);
+        twl4030_i2c_write_u8(TWL4030_MODULE_LED, 0x33, 0x0);
+
+        lcd_enabled = 0;
+}
+
+static struct omap_display_data omap3_evm_display_data_lcd = {
+        .type = OMAP_DISPLAY_TYPE_DPI,
+        .name = "lcd",
+        .panel_name = "panel-generic",
+        .u.dpi.data_lines = 24,
+        .panel_enable = omap3_evm_panel_enable_lcd,
+        .panel_disable = omap3_evm_panel_disable_lcd,
+};
+
+static int omap3_evm_panel_enable_tv(struct omap_display *display)
+{
+        return 0;
+}
+
+static void omap3_evm_panel_disable_tv(struct omap_display *display)
+{
+}
+
+static struct omap_display_data omap3_evm_display_data_tv = {
+        .type = OMAP_DISPLAY_TYPE_VENC,
+        .name = "tv",
+        .u.venc.type = OMAP_DSS_VENC_TYPE_SVIDEO,
+        .panel_enable = omap3_evm_panel_enable_tv,
+        .panel_disable = omap3_evm_panel_disable_tv,
+};
+
+static struct omap_dss_platform_data omap3_evm_dss_data = {
+        .num_displays = 2,
+        .displays = {
+                &omap3_evm_display_data_lcd,
+                &omap3_evm_display_data_tv,
+        }
+};
+static struct platform_device omap3_evm_dss_device = {
+        .name           = "omap-dss",
+        .id             = -1,
+        .dev            = {
+                .platform_data = &omap3_evm_dss_data,
+        },
+};
+#else
+static struct platform_device omap3_devkit8000_lcd_device = {
+	.name		= "omap3_devkit8000_lcd",
+	.id		= -1,
+};
+
+static struct omap_lcd_config omap3_devkit8000_lcd_config __initdata = {
+	.ctrl_name	= "internal",
+};
+#endif
+
+static struct gpio_led gpio_leds[] = {
+	{
+		.name			= "led1",
+		.default_trigger	= "heartbeat",
+		.gpio			= 186,
+		.active_low		= true,
+	},
+	{
+		.name			= "led2",
+		.default_trigger	= "mmc0",
+		.gpio			= 163,
+		.active_low		= true,
+	},
+	{
+		.name			= "ledB",
+		.default_trigger	= "none",
+		.gpio			= 153, 
+		.active_low             = true,
+	},
+	{
+		.name			= "led3",
+		.default_trigger	= "none",
+		.gpio			= 164,	/* gets replaced */
+		.active_low             = true,
+	},
+};
+
+static struct gpio_led_platform_data gpio_led_info = {
+	.leds		= gpio_leds,
+	.num_leds	= ARRAY_SIZE(gpio_leds),
+};
+
+static struct platform_device leds_gpio = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &gpio_led_info,
+	},
+};
+
+static struct gpio_keys_button gpio_buttons[] = {
+	{
+		.code			= BTN_EXTRA,
+		.gpio			= 26,
+		.desc			= "user",
+		.wakeup			= 1,
+	},
+};
+
+static struct gpio_keys_platform_data gpio_key_info = {
+	.buttons	= gpio_buttons,
+	.nbuttons	= ARRAY_SIZE(gpio_buttons),
+};
+
+static struct platform_device keys_gpio = {
+	.name	= "gpio-keys",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &gpio_key_info,
+	},
+};
+
+static struct w1_gpio_platform_data w1_gpio_pdata = {
+	.pin_in = 129,
+	.pin_out = 126,
+	.is_open_drain = 1,
+};
+
+static struct platform_device w1_device = {
+	.name = "w1-gpio",
+	.id = -1,
+	.dev.platform_data = &w1_gpio_pdata,
+};
+
+#define OMAP_DM9000_BASE	0x2c000000
+
+static struct resource omap_dm9000_resources[] = {
+	[0] = {
+		.start		= OMAP_DM9000_BASE,
+		.end		= (OMAP_DM9000_BASE + 0x4 - 1),
+		.flags		= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start		= (OMAP_DM9000_BASE + 0x400),
+		.end		= (OMAP_DM9000_BASE + 0x400 + 0x4 - 1),
+		.flags		= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start		= OMAP_GPIO_IRQ(OMAP_DM9000_GPIO_IRQ),
+		.end		= OMAP_GPIO_IRQ(OMAP_DM9000_GPIO_IRQ),
+		.flags		= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
+	},
+};
+
+static struct dm9000_plat_data omap_dm9000_platdata = {
+        .flags = DM9000_PLATF_16BITONLY,
+};
+
+static struct platform_device omap_dm9000_dev = {
+	.name = "dm9000",
+	.id = -1,
+	.num_resources	= ARRAY_SIZE(omap_dm9000_resources),
+	.resource	= omap_dm9000_resources,
+        .dev = {
+                .platform_data = &omap_dm9000_platdata,
+        },
+};
+
+static struct omap_board_config_kernel omap3_devkit8000_config[] __initdata = {
+	{ OMAP_TAG_UART,	&omap3_devkit8000_uart_config },
+#ifndef	CONFIG_OMAP2_DSS
+	{ OMAP_TAG_LCD,		&omap3_devkit8000_lcd_config },
+#endif
+};
+
+static struct platform_device *omap3_devkit8000_devices[] __initdata = {
+#ifdef CONFIG_OMAP2_DSS
+	&omap3_evm_dss_device,
+	&omap3evm_vout_device,
+#else
+	&omap3_devkit8000_lcd_device,
+#endif
+	&leds_gpio,
+	&keys_gpio,
+	&w1_device,
+	&omap_dm9000_dev,
+};
+
+static void __init omap3_devkit8000_flash_init(void)
+{
+	u8 cs = 0;
+	u8 nandcs = GPMC_CS_NUM + 1;
+
+	u32 gpmc_base_add = OMAP34XX_GPMC_VIRT;
+
+	/* find out the chip-select on which NAND exists */
+	while (cs < GPMC_CS_NUM) {
+		u32 ret = 0;
+		ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
+
+		if ((ret & 0xC00) == 0x800) {
+			printk(KERN_INFO "Found NAND on CS%d\n", cs);
+			if (nandcs > GPMC_CS_NUM)
+				nandcs = cs;
+		}
+		cs++;
+	}
+
+	if (nandcs > GPMC_CS_NUM) {
+		printk(KERN_INFO "NAND: Unable to find configuration "
+				 "in GPMC\n ");
+		return;
+	}
+
+	if (nandcs < GPMC_CS_NUM) {
+		omap3_devkit8000_nand_data.cs = nandcs;
+		omap3_devkit8000_nand_data.gpmc_cs_baseaddr = (void *)
+			(gpmc_base_add + GPMC_CS0_BASE + nandcs * GPMC_CS_SIZE);
+		omap3_devkit8000_nand_data.gpmc_baseaddr = (void *) (gpmc_base_add);
+
+		printk(KERN_INFO "Registering NAND on CS%d\n", nandcs);
+		if (platform_device_register(&omap3_devkit8000_nand_device) < 0)
+			printk(KERN_ERR "Unable to register NAND device\n");
+	}
+}
+
+static void __init omap3_devkit8000_init(void)
+{
+	omap3_devkit8000_i2c_init();
+	platform_add_devices(omap3_devkit8000_devices,
+			ARRAY_SIZE(omap3_devkit8000_devices));
+	omap_board_config = omap3_devkit8000_config;
+	omap_board_config_size = ARRAY_SIZE(omap3_devkit8000_config);
+
+	spi_register_board_info(omap3_devkit8000_spi_board_info,
+                                ARRAY_SIZE(omap3_devkit8000_spi_board_info));
+
+	omap_serial_init();
+
+	omap_cfg_reg(J25_34XX_GPIO170);
+	gpio_request(170, "DVI_nPD");
+	/* REVISIT leave DVI powered down until it's needed ... */
+	gpio_direction_output(170, true);
+
+	usb_musb_init();
+	usb_ehci_init();
+	omap3_devkit8000_flash_init();
+}
+
+static void __init omap3_devkit8000_map_io(void)
+{
+	omap2_set_globals_343x();
+	omap2_map_common_io();
+}
+
+MACHINE_START(OMAP3_DEVKIT8000, "OMAP3 DevKit8000 Board")
+	.phys_io	= 0x48000000,
+	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.boot_params	= 0x80000100,
+	.map_io		= omap3_devkit8000_map_io,
+	.init_irq	= omap3_devkit8000_init_irq,
+	.init_machine	= omap3_devkit8000_init,
+	.timer		= &omap_timer,
+MACHINE_END
+
+void usb_gpio_settings(void)
+{
+        unsigned char val;
+
+      //  if (get_omap3evm_board_rev() < OMAP3EVM_BOARD_GEN_2)
+        //        return;
+
+        /* enable VAUX2 for EHCI */
+        twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+                        TWL4030_VAUX2_1P8V, TWL4030_VAUX2_DEDICATED);
+        twl4030_i2c_write_u8(TWL4030_MODULE_PM_RECEIVER,
+                        ENABLE_VAUX2_DEV_GRP, TWL4030_VAUX2_DEV_GRP);
+
+        /* Enable TWL GPIO Module */
+        twl4030_i2c_write_u8(TWL4030_MODULE_GPIO, 0x04, REG_GPIO_CTRL);
+
+        /*
+ *          * Configure GPIO-6 as output
+ *                   */
+        twl4030_i2c_read_u8(TWL4030_MODULE_GPIO, &val, REG_GPIODATADIR1);
+        val |= 0x4;
+        twl4030_i2c_write_u8(TWL4030_MODULE_GPIO, val, REG_GPIODATADIR1);
+
+        /* Set GPIO6 = 1 */
+        twl4030_i2c_read_u8(TWL4030_MODULE_GPIO, &val, REG_GPIODATAOUT1);
+        val |= 0x40;
+        twl4030_i2c_write_u8(TWL4030_MODULE_GPIO, val, REG_GPIODATAOUT1);
+
+}
+EXPORT_SYMBOL(usb_gpio_settings);
+
+
diff -ruN linux-02.01.03.11-org/arch/arm/mach-omap2/board-omap3devkit8000-dc-v4l.c linux-02.01.03.11-new/arch/arm/mach-omap2/board-omap3devkit8000-dc-v4l.c
--- linux-02.01.03.11-org/arch/arm/mach-omap2/board-omap3devkit8000-dc-v4l.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-02.01.03.11-new/arch/arm/mach-omap2/board-omap3devkit8000-dc-v4l.c	2010-01-18 19:28:51.000000000 +0800
@@ -0,0 +1,456 @@
+/*
+ * arch/arm/mach-omap2/board-omap3evm-dc-v4l.c
+ *
+ * Driver for OMAP3 EVM Mass Market Daughter Card
+ *
+ * Copyright (C) 2008 Texas Instruments Inc
+ * Author: Vaibhav Hiremath <hvaibhav@ti.com>
+ *
+ * Contributors:
+ *     Anuj Aggarwal <anuj.aggarwal@ti.com>
+ *     Sivaraj R <sivaraj@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/videodev2.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <linux/i2c/twl4030.h>
+
+#include <mach/mux.h>
+
+#include <media/v4l2-int-device.h>
+#include <media/tvp514x.h>
+
+/* Include V4L2 ISP-Camera driver related header file */
+#include <../drivers/media/video/omap34xxcam.h>
+#include <../drivers/media/video/isp/ispreg.h>
+
+
+#include <../drivers/media/video/ov3640.h>
+#include <../drivers/media/video/isp/ispcsi2.h>
+
+#include "board-omap3evm-dc.h"
+
+#define MODULE_NAME			"omap3evmdc"
+
+/* Macro Definitions */
+
+/* GPIO pins */
+#if 0
+#define GPIO134_SEL_TVP_Y	(134)
+#define GPIO54_SEL_EXP_CAM	(54)
+#define GPIO136_SEL_CAM		(136)
+#else
+#define GPIO_CAM_PDN            (167)
+#define GPIO_CAM_RST            (126)
+#endif
+
+/* board internal information (BEGIN) */
+
+/* I2C bus to which all I2C slave devices are attached */
+#define BOARD_I2C_BUSNUM		(2)
+
+/* I2C address of chips present in board */
+#define TVP5146_I2C_ADDR		(0x5D)
+
+#if defined(CONFIG_VIDEO_TVP514X) || defined(CONFIG_VIDEO_TVP514X_MODULE)
+#if defined(CONFIG_VIDEO_OMAP3_CAM) || defined(CONFIG_VIDEO_OMAP3_CAM_MODULE)
+static struct omap34xxcam_hw_config decoder_hwc = {
+	.dev_index		= 0,
+	.dev_minor		= 0,
+	.dev_type		= OMAP34XXCAM_SLAVE_SENSOR,
+	.u.sensor.xclk		= OMAP34XXCAM_XCLK_NONE,
+	.u.sensor.sensor_isp	= 1,
+};
+
+static struct isp_interface_config tvp5146_if_config = {
+	.ccdc_par_ser		= ISP_PARLL_YUV_BT,
+	.dataline_shift		= 0x1,
+	.hsvs_syncdetect	= ISPCTRL_SYNC_DETECT_VSRISE,
+	.strobe			= 0x0,
+	.prestrobe		= 0x0,
+	.shutter		= 0x0,
+	.u.par.par_bridge	= 0x0,
+	.u.par.par_clk_pol	= 0x0,
+};
+#endif
+
+static struct v4l2_ifparm ifparm = {
+	.if_type = V4L2_IF_TYPE_BT656,
+	.u 	 = {
+		.bt656 = {
+			.frame_start_on_rising_vs = 1,
+			.bt_sync_correct	= 0,
+			.swap			= 0,
+			.latch_clk_inv		= 0,
+			.nobt_hs_inv		= 0,	/* active high */
+			.nobt_vs_inv		= 0,	/* active high */
+			.mode			= V4L2_IF_TYPE_BT656_MODE_BT_8BIT,
+			.clock_min		= TVP514X_XCLK_BT656,
+			.clock_max		= TVP514X_XCLK_BT656,
+		},
+	},
+};
+
+/**
+ * @brief tvp5146_ifparm - Returns the TVP5146 decoder interface parameters
+ *
+ * @param p - pointer to v4l2_ifparm structure
+ *
+ * @return result of operation - 0 is success
+ */
+static int tvp5146_ifparm(struct v4l2_ifparm *p)
+{
+	if (p == NULL)
+		return -EINVAL;
+
+	*p = ifparm;
+	return 0;
+}
+
+/**
+ * @brief tvp5146_set_prv_data - Returns tvp5146 omap34xx driver private data
+ *
+ * @param priv - pointer to omap34xxcam_hw_config structure
+ *
+ * @return result of operation - 0 is success
+ */
+static int tvp5146_set_prv_data(void *priv)
+{
+#if defined(CONFIG_VIDEO_OMAP3_CAM) || defined(CONFIG_VIDEO_OMAP3_CAM_MODULE)
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	if (priv == NULL)
+		return -EINVAL;
+
+	hwc->u.sensor.sensor_isp = decoder_hwc.u.sensor.sensor_isp;
+	hwc->u.sensor.xclk = decoder_hwc.u.sensor.xclk;
+	hwc->dev_index = decoder_hwc.dev_index;
+	hwc->dev_minor = decoder_hwc.dev_minor;
+	hwc->dev_type = decoder_hwc.dev_type;
+	return 0;
+#else
+	return -EINVAL;
+#endif
+}
+
+/**
+ * @brief omap3evmdc_set_mux - Sets mux to enable/disable signal routing to
+ *                             different peripherals present in board
+ * IMPORTANT - This function will take care of writing appropriate values for
+ * active low signals as well
+ *
+ * @param mux_id - enum, mux id to enable/disable
+ * @param value - enum, ENABLE_MUX for enabling and DISABLE_MUX for disabling
+ *
+ * @return result of operation - 0 is success
+ */
+static int omap3evmdc_set_mux(enum omap3evmdc_mux mux_id, enum config_mux value)
+{
+	int err = 0;
+
+	if (unlikely(mux_id >= NUM_MUX)) {
+		printk(KERN_ERR MODULE_NAME ": Invalid mux id\n");
+		return -EPERM;
+	}
+
+	switch (mux_id) {
+	case MUX_TVP5146:
+		if (ENABLE_MUX == value) {
+			/* Enable TVP5146 Video in (GPIO134 = 0) */
+//			gpio_set_value(GPIO134_SEL_TVP_Y, 0);
+			/* Disable Expansion Camera Video in (GPIO54 = 1) */
+//			gpio_set_value(GPIO54_SEL_EXP_CAM, 1);
+			/* Disable Camera Video in (GPIO136 = 1)*/
+//			gpio_set_value(GPIO136_SEL_CAM, 1);
+		} else {
+			/* Disable TVP5146 Video in (GPIO134 = 0) */
+//			gpio_set_value(GPIO134_SEL_TVP_Y, 1);
+		}
+		break;
+
+	case MUX_CAMERA_SENSOR:
+		if (ENABLE_MUX == value) {
+			/* Disable TVP5146 Video in (GPIO134 = 0) */
+//			gpio_set_value(GPIO134_SEL_TVP_Y, 1);
+			/* Disable Exapansion Camera Video in (GPIO54 = 1) */
+//			gpio_set_value(GPIO54_SEL_EXP_CAM, 1);
+			/* Enable Camera Video in (GPIO136 = 1) */
+//			gpio_set_value(GPIO136_SEL_CAM, 0);
+		} else {
+			/* Disable Camera Video in (GPIO136 = 1) */
+//			gpio_set_value(GPIO136_SEL_CAM, 1);
+		}
+		break;
+
+	case MUX_EXP_CAMERA_SENSOR:
+		if (ENABLE_MUX == value) {
+			/* Disable TVP5146 Video in (GPIO134 = 0) */
+//			gpio_set_value(GPIO134_SEL_TVP_Y, 1);
+			/* Enable Expansion Camera Video in (GPIO54 = 1) */
+//			gpio_set_value(GPIO54_SEL_EXP_CAM, 0);
+			/* Disable Camera Video in (GPIO136 = 1) */
+//			gpio_set_value(GPIO136_SEL_CAM, 1);
+		} else {
+			/* Disable Expansion Camera Video in (GPIO54 = 1) */
+//			gpio_set_value(GPIO54_SEL_EXP_CAM, 1);
+		}
+		break;
+
+	case NUM_MUX:
+	default:
+		printk(KERN_ERR "Invalid mux id\n");
+		err = -EPERM;
+	}
+
+	return err;
+}
+/**
+ * @brief tvp5146_power_set - Power-on or power-off TVP5146 device
+ *
+ * @param power - enum, Power on/off, resume/standby
+ *
+ * @return result of operation - 0 is success
+ */
+static int tvp5146_power_set(enum v4l2_power power)
+{
+	switch (power) {
+	case V4L2_POWER_OFF:
+		/* Disable mux for TVP5146 decoder data path */
+		if (omap3evmdc_set_mux(MUX_TVP5146, DISABLE_MUX))
+			return -ENODEV;
+		break;
+
+	case V4L2_POWER_STANDBY:
+		break;
+
+	case V4L2_POWER_ON:
+		/* Enable mux for TVP5146 decoder data path */
+		if (omap3evmdc_set_mux(MUX_TVP5146, ENABLE_MUX))
+			return -ENODEV;
+
+#if defined(CONFIG_VIDEO_OMAP3_CAM) || defined(CONFIG_VIDEO_OMAP3_CAM_MODULE)
+		isp_configure_interface(&tvp5146_if_config);
+#endif
+		break;
+
+	default:
+		return -ENODEV;
+		break;
+	}
+	return 0;
+}
+
+static struct tvp514x_platform_data tvp5146_pdata = {
+	.master		= "omap34xxcam",
+	.power_set	= tvp5146_power_set,
+	.priv_data_set	= tvp5146_set_prv_data,
+	.ifparm		= tvp5146_ifparm,
+	/* Some interface dependent params */
+	.clk_polarity	= 0, /* data clocked out on falling edge */
+	.hs_polarity	= 1, /* 0 - Active low, 1- Active high */
+	.vs_polarity	= 1, /* 0 - Active low, 1- Active high */
+};
+
+static struct i2c_board_info __initdata tvp5146_i2c_board_info = {
+	I2C_BOARD_INFO("tvp5146m2", TVP5146_I2C_ADDR),
+	.platform_data	= &tvp5146_pdata,
+};
+
+#endif				/* #ifdef CONFIG_VIDEO_TVP514X */
+
+#if defined(CONFIG_VIDEO_OV3640) || defined(CONFIG_VIDEO_OV3640_MODULE)
+static struct omap34xxcam_sensor_config ov3640_hwc = {
+	.sensor_isp = 1,
+	.xclk = OMAP34XXCAM_XCLK_NONE,
+//	.capture_mem = PAGE_ALIGN(2048 * 1536 * 2) * 2,
+};
+
+static struct isp_interface_config ov3640_if_config = {
+#if 1
+	.ccdc_par_ser = ISP_PARLL,
+	.dataline_shift = 0x1,
+	.hsvs_syncdetect = ISPCTRL_SYNC_DETECT_VSRISE,
+	.strobe = 0x0,
+	.prestrobe = 0x0,
+	.shutter = 0x0,
+	.u.par.par_bridge = /*0x0*/0x01,
+	.u.par.par_clk_pol = 0x0,
+#else
+        .ccdc_par_ser           = ISP_PARLL_YUV_BT,
+        .dataline_shift         = 0x1,
+        .hsvs_syncdetect        = ISPCTRL_SYNC_DETECT_VSRISE,
+        .strobe                 = 0x0,
+        .prestrobe              = 0x0,
+        .shutter                = 0x0,
+        .u.par.par_bridge       = 0x0,
+        .u.par.par_clk_pol      = 0x0,
+#endif
+};
+
+static int ov3640_sensor_set_prv_data(void *priv)
+{
+
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	if(priv == NULL)
+		return -EINVAL;
+
+	hwc->u.sensor.sensor_isp = ov3640_hwc.sensor_isp;
+	hwc->u.sensor.xclk = ov3640_hwc.xclk;
+//	hwc->u.sensor.capture_mem = ov3640_hwc.capture_mem;
+	hwc->dev_index = 0;
+	hwc->dev_minor = 0;
+	hwc->dev_type = OMAP34XXCAM_SLAVE_SENSOR;
+	return 0;
+}
+
+static int ov3640_sensor_power_set(enum v4l2_power power)
+{
+	static enum v4l2_power previous_power = V4L2_POWER_OFF;
+	switch (power) {
+	case V4L2_POWER_ON:
+		isp_configure_interface(&ov3640_if_config);
+		break;
+	case V4L2_POWER_OFF:
+		break;
+	case V4L2_POWER_STANDBY:
+		break;
+	}
+	previous_power = power;
+
+	return 0;
+}
+
+static struct ov3640_platform_data ov3640_platform_data = {
+	.power_set	 = ov3640_sensor_power_set,
+	.priv_data_set	 = ov3640_sensor_set_prv_data,
+	.default_regs	 = ov3640_common,
+};
+
+static struct i2c_board_info __initdata ov3640_i2c_board_info= {
+	I2C_BOARD_INFO("ov3640", OV3640_I2C_ADDR),
+	.platform_data = &ov3640_platform_data,
+};
+
+#endif
+
+
+
+/**
+ * @brief omap3evmdc_mdc_config - GPIO configuration for
+ *                          GPIO 134, 54 and 136
+ *
+ * @return result of operation - 0 is success
+ */
+static int omap3evmdc_mdc_config(void)
+{
+#if 0
+	/* Setting the MUX configuration */
+	omap_cfg_reg(AG4_34XX_GPIO134);
+	omap_cfg_reg(U8_34XX_GPIO54);
+	omap_cfg_reg(AE4_34XX_GPIO136);
+
+	if (gpio_request(GPIO134_SEL_TVP_Y, "TVP5146 Vid-in") < 0) {
+		printk(KERN_ERR MODULE_NAME ": Can't get GPIO 134\n");
+		return -EINVAL;
+	}
+
+	if (gpio_request(GPIO54_SEL_EXP_CAM, "EXP_CAM Vid-in") < 0) {
+		printk(KERN_ERR MODULE_NAME ": Can't get GPIO 54\n");
+		return -EINVAL;
+	}
+
+	if (gpio_request(GPIO136_SEL_CAM, "CAM Vid-in") < 0) {
+		printk(KERN_ERR MODULE_NAME ": Can't get GPIO 136\n");
+		return -EINVAL;
+	}
+
+	/* Make GPIO as output */
+	gpio_direction_output(GPIO134_SEL_TVP_Y, 0);
+	gpio_direction_output(GPIO54_SEL_EXP_CAM, 0);
+	gpio_direction_output(GPIO136_SEL_CAM, 0);
+#else
+        if (gpio_request(GPIO_CAM_PDN, "OV3640 PND") < 0) {
+                printk(KERN_ERR MODULE_NAME ": Can't get GPIO %d\n", GPIO_CAM_PDN);
+                return -EINVAL;
+        }
+
+        if (gpio_request(GPIO_CAM_RST, "OV3640 RST") < 0) {
+                printk(KERN_ERR MODULE_NAME ": Can't get GPIO %d\n", GPIO_CAM_RST);
+                return -EINVAL;
+        }
+
+        gpio_direction_output(GPIO_CAM_PDN, 0);
+        gpio_direction_output(GPIO_CAM_RST, 0);
+        mdelay(1);
+        gpio_direction_output(GPIO_CAM_RST, 1);
+	mdelay(1);
+#endif
+	return 0;
+}
+
+/**
+ * @brief omap3evmdc_init - module init function. Should be called before any
+ *                          client driver init call
+ *
+ * @return result of operation - 0 is success
+ */
+static int __init omap3evmdc_init(void)
+{
+	int err;
+
+	err = omap3evmdc_mdc_config();
+	if (err) {
+		printk(KERN_ERR MODULE_NAME ": MDC configuration failed \n");
+		return err;
+	}
+
+	/*
+	 * Register the I2C devices present in the board to the I2C
+	 * framework.
+	 * If more I2C devices are added, then each device information should
+	 * be registered with I2C using i2c_register_board_info().
+	 */
+#if defined(CONFIG_VIDEO_TVP514X) || defined(CONFIG_VIDEO_TVP514X_MODULE)
+	err = i2c_register_board_info(BOARD_I2C_BUSNUM,
+					&tvp5146_i2c_board_info, 1);
+	if (err) {
+		printk(KERN_ERR MODULE_NAME \
+				": TVP5146 I2C Board Registration failed \n");
+		return err;
+	}
+#endif
+
+#if defined(CONFIG_VIDEO_OV3640) || defined(CONFIG_VIDEO_OV3640_MODULE)
+        err = i2c_register_board_info(BOARD_I2C_BUSNUM,
+                                        &ov3640_i2c_board_info, 1);
+        if (err) {
+                printk(KERN_ERR MODULE_NAME \
+                                ": OV3640 I2C Board Registration failed \n");
+                return err;
+        }
+#endif
+	printk(KERN_INFO MODULE_NAME ": Driver registration complete \n");
+
+	return 0;
+}
+
+arch_initcall(omap3evmdc_init);
diff -ruN linux-02.01.03.11-org/arch/arm/mach-omap2/board-omap3evm-dc.h linux-02.01.03.11-new/arch/arm/mach-omap2/board-omap3evm-dc.h
--- linux-02.01.03.11-org/arch/arm/mach-omap2/board-omap3evm-dc.h	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/arch/arm/mach-omap2/board-omap3evm-dc.h	2010-01-18 20:23:44.000000000 +0800
@@ -40,5 +40,5 @@
 	ENABLE_MUX
 };
 
-int omap3evmdc_init(int dec_sts, int dec_i2c_bus, int dec_i2c_id);
+//int omap3evmdc_init(int dec_sts, int dec_i2c_bus, int dec_i2c_id);
 #endif		/* __BOARD_OMAP3EVM_DC_H_ */
diff -ruN linux-02.01.03.11-org/arch/arm/mach-omap2/Kconfig linux-02.01.03.11-new/arch/arm/mach-omap2/Kconfig
--- linux-02.01.03.11-org/arch/arm/mach-omap2/Kconfig	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/arch/arm/mach-omap2/Kconfig	2010-01-18 19:33:46.000000000 +0800
@@ -156,6 +156,30 @@
 config MACH_OMAP3_BEAGLE
 	bool "OMAP3 BEAGLE board"
 	depends on ARCH_OMAP3 && ARCH_OMAP34XX
+config MACH_OMAP3_DEVKIT8000
+         bool "OMAP3 DEVKIT8000 board"
+         depends on ARCH_OMAP3 && ARCH_OMAP34XX
+
+config MACH_OMAP3_DevKit8000_MMDC
+         bool "DevKit8000 Camera Daughter Card board"
+         depends on MACH_OMAP3_DEVKIT8000
+         help
+           Set this if you've got a Camera Daughter Card board.
+
+config OMAP_TICK_GPTIMER
+         int "GPTIMER used for system tick timer"
+         depends on ARCH_OMAP2 || ARCH_OMAP3
+         range 1 12
+         default 1
+         help
+           Linux uses one of the twelve on-board OMAP GPTIMER blocks to generate
+           system tick interrupts.  The twelve GPTIMERs have slightly
+           different powerdomain, source clock, and security properties
+           (mostly documented in the OMAP3 TRMs) that can affect the selection
+           of which GPTIMER to use.  The historical default is GPTIMER1.
+           If CONFIG_OMAP_32K_TIMER is selected, Beagle may require GPTIMER12
+           due to hardware sensitivity to glitches on the OMAP 32kHz clock
+           input.
 
 config MACH_OVERO
 	bool "Gumstix Overo board"
diff -ruN linux-02.01.03.11-org/arch/arm/mach-omap2/Makefile linux-02.01.03.11-new/arch/arm/mach-omap2/Makefile
--- linux-02.01.03.11-org/arch/arm/mach-omap2/Makefile	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/arch/arm/mach-omap2/Makefile	2010-01-19 21:23:54.000000000 +0800
@@ -41,6 +41,9 @@
 
 # Debobs
 obj-$(CONFIG_OMAP3_DEBOBS)	+= debobs.o
+ obj-$(CONFIG_OMAP_MMU_FWK)      += mmu_mach.o
+ mmu_mach-objs                   := mmu.o
+
 
 # Specific board support
 obj-$(CONFIG_MACH_OMAP_GENERIC)		+= board-generic.o
@@ -67,6 +70,11 @@
 					   usb-musb.o usb-ehci.o \
 					   mmc-twl4030.o \
 					   twl4030-generic-scripts.o
+obj-$(CONFIG_MACH_OMAP3_DEVKIT8000)     +=board-omap3devkit8000.o \
+					   usb-musb.o usb-ehci.o \
+                                           mmc-twl4030.o \
+                                           twl4030-generic-scripts.o
+ obj-$(CONFIG_MACH_OMAP3_DevKit8000_MMDC)+= board-omap3devkit8000-dc-v4l.o
 obj-$(CONFIG_MACH_OMAP_LDP)		+= board-ldp.o \
 					   mmc-twl4030.o \
 					   usb-musb.o
diff -ruN linux-02.01.03.11-org/arch/arm/mach-omap2/mmu.c linux-02.01.03.11-new/arch/arm/mach-omap2/mmu.c
--- linux-02.01.03.11-org/arch/arm/mach-omap2/mmu.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-02.01.03.11-new/arch/arm/mach-omap2/mmu.c	2010-01-18 19:30:07.000000000 +0800
@@ -0,0 +1,330 @@
+/*
+ * linux/arch/arm/mach-omap2/mmu.c
+ *
+ * Support for non-MPU OMAP2 MMUs.
+ *
+ * Copyright (C) 2002-2007 Nokia Corporation
+ *
+ * Written by Toshihiro Kobayashi <toshihiro.kobayashi@nokia.com>
+ *        and Paul Mundt <paul.mundt@nokia.com>
+ *
+ * TWL support: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/rwsem.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include "mmu.h"
+#include <mach/mmu.h>
+#include <asm/tlbflush.h>
+#include <asm/sizes.h>
+
+static void *dspvect_page;
+#define DSP_INIT_PAGE	0xfff000
+
+static inline void
+omap2_mmu_read_tlb(struct omap_mmu *mmu, struct cam_ram_regset *cr)
+{
+	cr->cam = omap_mmu_read_reg(mmu, OMAP_MMU_READ_CAM);
+	cr->ram = omap_mmu_read_reg(mmu, OMAP_MMU_READ_RAM);
+}
+
+static inline void
+omap2_mmu_load_tlb(struct omap_mmu *mmu, struct cam_ram_regset *cr)
+{
+	/* Set the CAM and RAM entries */
+	omap_mmu_write_reg(mmu, cr->cam | OMAP_MMU_CAM_V, OMAP_MMU_CAM);
+	omap_mmu_write_reg(mmu, cr->ram, OMAP_MMU_RAM);
+}
+
+static void exmap_setup_iomap_page(struct omap_mmu *mmu, unsigned long phys,
+				   unsigned long dsp_io_adr, int index)
+{
+	unsigned long dspadr;
+	void *virt;
+	struct omap_mmu_tlb_entry tlb_ent;
+
+	dspadr = (IOMAP_VAL << 18) + (dsp_io_adr << 1);
+	virt = omap_mmu_to_virt(mmu, dspadr);
+	exmap_set_armmmu(mmu, (unsigned long)virt, phys, PAGE_SIZE);
+	INIT_EXMAP_TBL_ENTRY_4KB_PRESERVED(mmu->exmap_tbl + index, NULL, virt);
+	INIT_TLB_ENTRY_4KB_ES32_PRESERVED(&tlb_ent, dspadr, phys);
+	omap_mmu_load_pte_entry(mmu, &tlb_ent);
+}
+
+static void exmap_clear_iomap_page(struct omap_mmu *mmu,
+				   unsigned long dsp_io_adr)
+{
+	unsigned long dspadr;
+	void *virt;
+
+	dspadr = (IOMAP_VAL << 18) + (dsp_io_adr << 1);
+	virt = omap_mmu_to_virt(mmu, dspadr);
+	exmap_clear_armmmu(mmu, (unsigned long)virt, PAGE_SIZE);
+	/* DSP MMU is shutting down. not handled here. */
+}
+
+#define OMAP24XX_MAILBOX_BASE	(L4_24XX_BASE + 0x94000)
+#define OMAP2420_GPT5_BASE	(L4_24XX_BASE + 0x7c000)
+#define OMAP2420_GPT6_BASE	(L4_24XX_BASE + 0x7e000)
+#define OMAP2420_GPT7_BASE	(L4_24XX_BASE + 0x80000)
+#define OMAP2420_GPT8_BASE	(L4_24XX_BASE + 0x82000)
+#define OMAP24XX_EAC_BASE	(L4_24XX_BASE + 0x90000)
+#define OMAP24XX_STI_BASE	(L4_24XX_BASE + 0x68000)
+#define OMAP24XX_STI_CH_BASE	(L4_24XX_BASE + 0x0c000000)
+
+static int exmap_setup_preserved_entries(struct omap_mmu *mmu)
+{
+	int i, n = 0;
+
+	exmap_setup_preserved_mem_page(mmu, dspvect_page, DSP_INIT_PAGE, n++);
+
+	/* REVISIT: This will need to be revisited for 3430 */
+	exmap_setup_iomap_page(mmu, OMAP2_PRCM_BASE, 0x7000, n++);
+	exmap_setup_iomap_page(mmu, OMAP24XX_MAILBOX_BASE, 0x11000, n++);
+
+	if (cpu_is_omap2420()) {
+		exmap_setup_iomap_page(mmu, OMAP2420_GPT5_BASE, 0xe000, n++);
+		exmap_setup_iomap_page(mmu, OMAP2420_GPT6_BASE, 0xe800, n++);
+		exmap_setup_iomap_page(mmu, OMAP2420_GPT7_BASE, 0xf000, n++);
+		exmap_setup_iomap_page(mmu, OMAP2420_GPT8_BASE, 0xf800, n++);
+		exmap_setup_iomap_page(mmu, OMAP24XX_EAC_BASE,  0x10000, n++);
+		exmap_setup_iomap_page(mmu, OMAP24XX_STI_BASE, 0xc800, n++);
+		for (i = 0; i < 5; i++)
+			exmap_setup_preserved_mem_page(mmu,
+				__va(OMAP24XX_STI_CH_BASE + i*SZ_4K),
+				0xfb0000 + i*SZ_4K, n++);
+	}
+
+	return n;
+}
+
+static void exmap_clear_preserved_entries(struct omap_mmu *mmu)
+{
+	int i;
+
+	exmap_clear_iomap_page(mmu, 0x7000);	/* PRCM registers */
+	exmap_clear_iomap_page(mmu, 0x11000);	/* MAILBOX registers */
+
+	if (cpu_is_omap2420()) {
+		exmap_clear_iomap_page(mmu, 0xe000);	/* GPT5 */
+		exmap_clear_iomap_page(mmu, 0xe800);	/* GPT6 */
+		exmap_clear_iomap_page(mmu, 0xf000);	/* GPT7 */
+		exmap_clear_iomap_page(mmu, 0xf800);	/* GPT8 */
+		exmap_clear_iomap_page(mmu, 0x10000);	/* EAC */
+		exmap_clear_iomap_page(mmu, 0xc800);	/* STI */
+		for (i = 0; i < 5; i++)			/* STI CH */
+			exmap_clear_mem_page(mmu, 0xfb0000 + i*SZ_4K);
+	}
+
+	exmap_clear_mem_page(mmu, DSP_INIT_PAGE);
+}
+
+#define MMU_IRQ_MASK \
+	(OMAP_MMU_IRQ_MULTIHITFAULT | \
+	 OMAP_MMU_IRQ_TABLEWALKFAULT | \
+	 OMAP_MMU_IRQ_EMUMISS | \
+	 OMAP_MMU_IRQ_TRANSLATIONFAULT)
+
+static int omap2_mmu_startup(struct omap_mmu *mmu)
+{
+	u32 rev = omap_mmu_read_reg(mmu, OMAP_MMU_REVISION);
+
+	pr_info("MMU: OMAP %s MMU initialized (HW v%d.%d)\n", mmu->name,
+		(rev >> 4) & 0xf, rev & 0xf);
+
+	dspvect_page = (void *)__get_dma_pages(GFP_KERNEL, 0);
+	if (dspvect_page == NULL) {
+		dev_err(mmu->dev, "MMU %s: failed to allocate memory "
+			"for vector table\n", mmu->name);
+		return -ENOMEM;
+	}
+
+	mmu->nr_exmap_preserved = exmap_setup_preserved_entries(mmu);
+
+	omap_mmu_write_reg(mmu, MMU_IRQ_MASK, OMAP_MMU_IRQENABLE);
+
+	return 0;
+}
+
+static void omap2_mmu_shutdown(struct omap_mmu *mmu)
+{
+	exmap_clear_preserved_entries(mmu);
+
+	if (dspvect_page != NULL) {
+		unsigned long virt;
+
+		down_read(&mmu->exmap_sem);
+
+		virt = (unsigned long)omap_mmu_to_virt(mmu, DSP_INIT_PAGE);
+		flush_tlb_kernel_range(virt, virt + PAGE_SIZE);
+		free_page((unsigned long)dspvect_page);
+		dspvect_page = NULL;
+
+		up_read(&mmu->exmap_sem);
+	}
+}
+
+static ssize_t omap2_mmu_show(struct omap_mmu *mmu, char *buf,
+			      struct omap_mmu_tlb_lock *tlb_lock)
+{
+	int i, len;
+
+	len = sprintf(buf, "P: preserved, V: valid\n"
+			   "B: big endian, L:little endian, "
+			   "M: mixed page attribute\n"
+			   "ety P V size   cam_va     ram_pa E ES M\n");
+			 /* 00: P V  4KB 0x300000 0x10171800 B 16 M */
+
+	for (i = 0; i < mmu->nr_tlb_entries; i++) {
+		struct omap_mmu_tlb_entry ent;
+		struct cam_ram_regset cr;
+		struct omap_mmu_tlb_lock entry_lock;
+		char *pgsz_str, *elsz_str;
+
+		/* read a TLB entry */
+		entry_lock.base   = tlb_lock->base;
+		entry_lock.victim = i;
+		omap_mmu_read_tlb(mmu, &entry_lock, &cr);
+
+		ent.pgsz   = cr.cam & OMAP_MMU_CAM_PAGESIZE_MASK;
+		ent.prsvd  = cr.cam & OMAP_MMU_CAM_P;
+		ent.valid  = cr.cam & OMAP_MMU_CAM_V;
+		ent.va     = cr.cam & OMAP_MMU_CAM_VATAG_MASK;
+		ent.endian = cr.ram & OMAP_MMU_RAM_ENDIANNESS;
+		ent.elsz   = cr.ram & OMAP_MMU_RAM_ELEMENTSIZE_MASK;
+		ent.pa     = cr.ram & OMAP_MMU_RAM_PADDR_MASK;
+		ent.mixed  = cr.ram & OMAP_MMU_RAM_MIXED;
+
+		pgsz_str = (ent.pgsz == OMAP_MMU_CAM_PAGESIZE_16MB) ? "64MB":
+			   (ent.pgsz == OMAP_MMU_CAM_PAGESIZE_1MB)  ? " 1MB":
+			   (ent.pgsz == OMAP_MMU_CAM_PAGESIZE_64KB) ? "64KB":
+			   (ent.pgsz == OMAP_MMU_CAM_PAGESIZE_4KB)  ? " 4KB":
+								     " ???";
+		elsz_str = (ent.elsz == OMAP_MMU_RAM_ELEMENTSIZE_8)  ? " 8":
+			   (ent.elsz == OMAP_MMU_RAM_ELEMENTSIZE_16) ? "16":
+			   (ent.elsz == OMAP_MMU_RAM_ELEMENTSIZE_32) ? "32":
+								      "??";
+
+		if (i == tlb_lock->base)
+			len += sprintf(buf + len, "lock base = %d\n",
+				       tlb_lock->base);
+		if (i == tlb_lock->victim)
+			len += sprintf(buf + len, "victim    = %d\n",
+				       tlb_lock->victim);
+
+		len += sprintf(buf + len,
+			       /* 00: P V  4KB 0x300000 0x10171800 B 16 M */
+			       "%02d: %c %c %s 0x%06lx 0x%08lx %c %s %c\n",
+			       i,
+			       ent.prsvd ? 'P' : ' ',
+			       ent.valid ? 'V' : ' ',
+			       pgsz_str, ent.va, ent.pa,
+			       ent.endian ? 'B' : 'L',
+			       elsz_str,
+			       ent.mixed ? 'M' : ' ');
+	}
+
+	return len;
+}
+
+#define get_cam_va_mask(pgsz) \
+	(((pgsz) == OMAP_MMU_CAM_PAGESIZE_16MB) ? 0xff000000 : \
+	 ((pgsz) == OMAP_MMU_CAM_PAGESIZE_1MB)  ? 0xfff00000 : \
+	 ((pgsz) == OMAP_MMU_CAM_PAGESIZE_64KB) ? 0xffff0000 : \
+	 ((pgsz) == OMAP_MMU_CAM_PAGESIZE_4KB)  ? 0xfffff000 : 0)
+
+static inline unsigned long omap2_mmu_cam_va(struct cam_ram_regset *cr)
+{
+	unsigned int page_size = cr->cam & OMAP_MMU_CAM_PAGESIZE_MASK;
+	unsigned int mask = get_cam_va_mask(cr->cam & page_size);
+
+	return cr->cam & mask;
+}
+
+static struct cam_ram_regset *
+omap2_mmu_cam_ram_alloc(struct omap_mmu *mmu, struct omap_mmu_tlb_entry *entry)
+{
+	struct cam_ram_regset *cr;
+
+	if (entry->va & ~(get_cam_va_mask(entry->pgsz))) {
+		dev_err(mmu->dev, "MMU %s: mapping vadr (0x%06lx) is not on"
+			" an aligned boundary\n", mmu->name, entry->va);
+		return ERR_PTR(-EINVAL);
+	}
+
+	cr = kmalloc(sizeof(struct cam_ram_regset), GFP_KERNEL);
+
+	cr->cam = (entry->va & OMAP_MMU_CAM_VATAG_MASK) |
+		  entry->prsvd | entry->pgsz;
+	cr->ram = entry->pa | entry->endian | entry->elsz;
+
+	return cr;
+}
+
+static inline int omap2_mmu_cam_ram_valid(struct cam_ram_regset *cr)
+{
+	return cr->cam & OMAP_MMU_CAM_V;
+}
+
+static void omap2_mmu_interrupt(struct omap_mmu *mmu)
+{
+	unsigned long status, va;
+
+	status = MMU_IRQ_MASK & omap_mmu_read_reg(mmu, OMAP_MMU_IRQSTATUS);
+	va = omap_mmu_read_reg(mmu, OMAP_MMU_FAULT_AD);
+
+	pr_info("%s\n", (status & OMAP_MMU_IRQ_MULTIHITFAULT)?
+		"multi hit":"");
+	pr_info("%s\n", (status & OMAP_MMU_IRQ_TABLEWALKFAULT)?
+		"table walk fault":"");
+	pr_info("%s\n", (status & OMAP_MMU_IRQ_EMUMISS)?
+		"EMU miss":"");
+	pr_info("%s\n", (status & OMAP_MMU_IRQ_TRANSLATIONFAULT)?
+		"translation fault":"");
+	pr_info("%s\n", (status & OMAP_MMU_IRQ_TLBMISS)?
+		"TLB miss":"");
+	pr_info("fault address = %#08lx\n", va);
+
+	omap_mmu_disable(mmu);
+	omap_mmu_write_reg(mmu, status, OMAP_MMU_IRQSTATUS);
+
+	mmu->fault_address = va;
+	schedule_work(&mmu->irq_work);
+}
+
+static pgprot_t omap2_mmu_pte_get_attr(struct omap_mmu_tlb_entry *entry)
+{
+	u32 attr;
+
+	attr = entry->mixed << 5;
+	attr |= entry->endian;
+	attr |= entry->elsz >> 3;
+	attr <<= ((entry->pgsz & OMAP_MMU_CAM_PAGESIZE_4KB) ? 0:6);
+
+	return attr;
+}
+
+struct omap_mmu_ops omap2_mmu_ops = {
+	.startup	= omap2_mmu_startup,
+	.shutdown	= omap2_mmu_shutdown,
+	.read_tlb	= omap2_mmu_read_tlb,
+	.load_tlb	= omap2_mmu_load_tlb,
+	.show		= omap2_mmu_show,
+	.cam_va		= omap2_mmu_cam_va,
+	.cam_ram_alloc	= omap2_mmu_cam_ram_alloc,
+	.cam_ram_valid	= omap2_mmu_cam_ram_valid,
+	.interrupt	= omap2_mmu_interrupt,
+	.pte_get_attr	= omap2_mmu_pte_get_attr,
+};
+EXPORT_SYMBOL_GPL(omap2_mmu_ops);
+
+MODULE_LICENSE("GPL");
diff -ruN linux-02.01.03.11-org/arch/arm/mach-omap2/mmu.h linux-02.01.03.11-new/arch/arm/mach-omap2/mmu.h
--- linux-02.01.03.11-org/arch/arm/mach-omap2/mmu.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-02.01.03.11-new/arch/arm/mach-omap2/mmu.h	2010-01-18 19:29:25.000000000 +0800
@@ -0,0 +1,117 @@
+#ifndef __MACH_OMAP2_MMU_H
+#define __MACH_OMAP2_MMU_H
+
+#include <linux/io.h>
+#include <mach/mmu.h>
+
+#define MMU_LOCK_BASE_MASK		(0x1f << 10)
+#define MMU_LOCK_VICTIM_MASK		(0x1f << 4)
+
+#define OMAP_MMU_REVISION		0x00
+#define OMAP_MMU_SYSCONFIG		0x10
+#define OMAP_MMU_SYSSTATUS		0x14
+#define OMAP_MMU_IRQSTATUS		0x18
+#define OMAP_MMU_IRQENABLE		0x1c
+#define OMAP_MMU_WALKING_ST		0x40
+#define OMAP_MMU_CNTL			0x44
+#define OMAP_MMU_FAULT_AD		0x48
+#define OMAP_MMU_TTB			0x4c
+#define OMAP_MMU_LOCK			0x50
+#define OMAP_MMU_LD_TLB			0x54
+#define OMAP_MMU_CAM			0x58
+#define OMAP_MMU_RAM			0x5c
+#define OMAP_MMU_GFLUSH			0x60
+#define OMAP_MMU_FLUSH_ENTRY		0x64
+#define OMAP_MMU_READ_CAM		0x68
+#define OMAP_MMU_READ_RAM		0x6c
+#define OMAP_MMU_EMU_FAULT_AD		0x70
+
+#define OMAP_MMU_CNTL_BURST_16MNGT_EN   0x0020
+#define OMAP_MMU_CNTL_WTL_EN            0x0004
+#define OMAP_MMU_CNTL_MMU_EN            0x0002
+#define OMAP_MMU_CNTL_RESET_SW          0x0001
+
+#define OMAP_MMU_IRQ_MULTIHITFAULT	0x00000010
+#define OMAP_MMU_IRQ_TABLEWALKFAULT	0x00000008
+#define OMAP_MMU_IRQ_EMUMISS		0x00000004
+#define OMAP_MMU_IRQ_TRANSLATIONFAULT	0x00000002
+#define OMAP_MMU_IRQ_TLBMISS		0x00000001
+
+#define OMAP_MMU_CAM_VATAG_MASK		0xfffff000
+#define OMAP_MMU_CAM_P			0x00000008
+#define OMAP_MMU_CAM_V			0x00000004
+#define OMAP_MMU_CAM_PAGESIZE_MASK	0x00000003
+#define OMAP_MMU_CAM_PAGESIZE_1MB	0x00000000
+#define OMAP_MMU_CAM_PAGESIZE_64KB	0x00000001
+#define OMAP_MMU_CAM_PAGESIZE_4KB	0x00000002
+#define OMAP_MMU_CAM_PAGESIZE_16MB	0x00000003
+
+#define OMAP_MMU_RAM_PADDR_MASK		0xfffff000
+#define OMAP_MMU_RAM_ENDIANNESS		0x00000200
+#define OMAP_MMU_RAM_ENDIANNESS_BIG	0x00000200
+#define OMAP_MMU_RAM_ENDIANNESS_LITTLE	0x00000000
+#define OMAP_MMU_RAM_ELEMENTSIZE_MASK	0x00000180
+#define OMAP_MMU_RAM_ELEMENTSIZE_8	0x00000000
+#define OMAP_MMU_RAM_ELEMENTSIZE_16	0x00000080
+#define OMAP_MMU_RAM_ELEMENTSIZE_32	0x00000100
+#define OMAP_MMU_RAM_ELEMENTSIZE_NONE	0x00000180
+#define OMAP_MMU_RAM_MIXED		0x00000040
+
+#define IOMAP_VAL	0x3f
+
+#define INIT_TLB_ENTRY(ent, v, p, ps)				\
+do {								\
+	(ent)->va	= (v);					\
+	(ent)->pa	= (p);					\
+	(ent)->pgsz	= (ps);					\
+	(ent)->prsvd	= 0;					\
+	(ent)->endian	= OMAP_MMU_RAM_ENDIANNESS_LITTLE;	\
+	(ent)->elsz	= OMAP_MMU_RAM_ELEMENTSIZE_16;		\
+	(ent)->mixed	= 0;					\
+	(ent)->tlb	= 1;					\
+} while (0)
+
+#define INIT_TLB_ENTRY_4KB_PRESERVED(ent, v, p)		\
+do {								\
+	(ent)->va	= (v);					\
+	(ent)->pa	= (p);					\
+	(ent)->pgsz	= OMAP_MMU_CAM_PAGESIZE_4KB;		\
+	(ent)->prsvd	= OMAP_MMU_CAM_P;			\
+	(ent)->endian	= OMAP_MMU_RAM_ENDIANNESS_LITTLE;	\
+	(ent)->elsz	= OMAP_MMU_RAM_ELEMENTSIZE_16;		\
+	(ent)->mixed	= 0;					\
+} while (0)
+
+#define INIT_TLB_ENTRY_4KB_ES32_PRESERVED(ent, v, p)		\
+do {								\
+	(ent)->va	= (v);					\
+	(ent)->pa	= (p);					\
+	(ent)->pgsz	= OMAP_MMU_CAM_PAGESIZE_4KB;		\
+	(ent)->prsvd	= OMAP_MMU_CAM_P;			\
+	(ent)->endian	= OMAP_MMU_RAM_ENDIANNESS_LITTLE;	\
+	(ent)->elsz	= OMAP_MMU_RAM_ELEMENTSIZE_32;		\
+	(ent)->mixed	= 0;					\
+} while (0)
+
+struct omap_mmu_tlb_entry {
+	unsigned long va;
+	unsigned long pa;
+	unsigned int pgsz, prsvd, valid;
+
+	u32 endian, elsz, mixed;
+	unsigned int tlb;
+};
+
+static inline unsigned long
+omap_mmu_read_reg(struct omap_mmu *mmu, unsigned long reg)
+{
+	return __raw_readl((void __iomem *)(mmu->base + reg));
+}
+
+static inline void omap_mmu_write_reg(struct omap_mmu *mmu,
+			       unsigned long val, unsigned long reg)
+{
+	__raw_writel(val, (void __iomem *)(mmu->base + reg));
+}
+
+#endif /* __MACH_OMAP2_MMU_H */
diff -ruN linux-02.01.03.11-org/arch/arm/mach-omap2/usb-musb.c linux-02.01.03.11-new/arch/arm/mach-omap2/usb-musb.c
--- linux-02.01.03.11-org/arch/arm/mach-omap2/usb-musb.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/arch/arm/mach-omap2/usb-musb.c	2010-01-20 09:12:41.000000000 +0800
@@ -33,6 +33,7 @@
 #include <mach/pm.h>
 #include <mach/mux.h>
 #include <mach/usb.h>
+#include <mach/board.h>
 
 #define AUTOIDLE        (1 << 0)
 #define OTG_SYSCONFIG	(OMAP34XX_HSUSB_OTG_BASE + 0x404)
@@ -163,6 +164,7 @@
 
 void __init usb_musb_init(void)
 {
+#if 0
 #ifdef CONFIG_USB_MUSB_SOC
 	/* OMAP35x new EVM can source 500mA */
 	if (get_omap3evm_board_rev() >= OMAP3EVM_BOARD_GEN_2)
@@ -171,11 +173,13 @@
 #ifdef CONFIG_NOP_USB_XCEIV
        nop_xceiv_register();
 #endif
+#endif
+#endif
 	if (platform_device_register(&musb_device) < 0) {
 		printk(KERN_ERR "Unable to register HS-USB (MUSB) device\n");
 		return;
 	}
-#endif
+
 	/* Enable smartidle on MUSB to improve C1 wakeup latency */
 	if (cpu_is_omap34xx())
 		omap_writel(AUTOIDLE, OTG_SYSCONFIG);
diff -ruN linux-02.01.03.11-org/arch/arm/plat-omap/dss/dss.c linux-02.01.03.11-new/arch/arm/plat-omap/dss/dss.c
--- linux-02.01.03.11-org/arch/arm/plat-omap/dss/dss.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/arch/arm/plat-omap/dss/dss.c	2010-01-20 09:28:30.000000000 +0800
@@ -535,7 +535,7 @@
 		r = -ENOMEM;
 		goto fail0;
 	}
-
+	omap_writel(omap_readl(0x48050440) & ~0x3, 0x48050440);
 	/* We need to wait here a bit, otherwise we sometimes start to get
 	 * synclost errors. I believe we could wait for one framedone or
 	 * perhaps vsync interrupt, but, because dispc is not initialized yet,
diff -ruN linux-02.01.03.11-org/arch/arm/plat-omap/include/mach/cpu.h linux-02.01.03.11-new/arch/arm/plat-omap/include/mach/cpu.h
--- linux-02.01.03.11-org/arch/arm/plat-omap/include/mach/cpu.h	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/arch/arm/plat-omap/include/mach/cpu.h	2010-01-18 20:22:30.000000000 +0800
@@ -323,6 +323,8 @@
 #define cpu_is_omap2423()		0
 #define cpu_is_omap2430()		0
 #define cpu_is_omap3430()		0
+#define cpu_is_omap3525()               0
+#define cpu_is_omap3530()               0
 
 #if defined(MULTI_OMAP1)
 # if defined(CONFIG_ARCH_OMAP730)
diff -ruN linux-02.01.03.11-org/arch/arm/tools/mach-types linux-02.01.03.11-new/arch/arm/tools/mach-types
--- linux-02.01.03.11-org/arch/arm/tools/mach-types	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/arch/arm/tools/mach-types	2010-01-18 20:15:07.000000000 +0800
@@ -1988,7 +1988,7 @@
 qq2440			MACH_QQ2440		QQ2440			1998
 mini2440		MACH_MINI2440		MINI2440		1999
 colibri300		MACH_COLIBRI300		COLIBRI300		2000
-jades			MACH_JADES		JADES			2001
+omap3_devkit8000        MACH_OMAP3_DEVKIT8000   OMAP3_DEVKIT8000        2001
 spark			MACH_SPARK		SPARK			2002
 benzina			MACH_BENZINA		BENZINA			2003
 blaze			MACH_BLAZE		BLAZE			2004
diff -ruN linux-02.01.03.11-org/drivers/mmc/card/block.c linux-02.01.03.11-new/drivers/mmc/card/block.c
--- linux-02.01.03.11-org/drivers/mmc/card/block.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/card/block.c	2010-01-18 20:34:31.000000000 +0800
@@ -145,7 +145,7 @@
 static u32 mmc_sd_num_wr_blocks(struct mmc_card *card)
 {
 	int err;
-	__be32 blocks;
+	u32 blocks;
 
 	struct mmc_request mrq;
 	struct mmc_command cmd;
@@ -204,24 +204,9 @@
 	if (cmd.error || data.error)
 		return (u32)-1;
 
-	return ntohl(blocks);
-}
-
-static u32 get_card_status(struct mmc_card *card, struct request *req)
-{
-	struct mmc_command cmd;
-	int err;
+	blocks = ntohl(blocks);
 
-	memset(&cmd, 0, sizeof(struct mmc_command));
-	cmd.opcode = MMC_SEND_STATUS;
-	if (!mmc_host_is_spi(card->host))
-		cmd.arg = card->rca << 16;
-	cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
-	err = mmc_wait_for_cmd(card->host, &cmd, 0);
-	if (err)
-		printk(KERN_ERR "%s: error %d sending status comand",
-		       req->rq_disk->disk_name, err);
-	return cmd.resp[0];
+	return blocks;
 }
 
 static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
@@ -229,13 +214,13 @@
 	struct mmc_blk_data *md = mq->data;
 	struct mmc_card *card = md->queue.card;
 	struct mmc_blk_request brq;
-	int ret = 1, disable_multi = 0;
+	int ret = 1;
 
 	mmc_claim_host(card->host);
 
 	do {
 		struct mmc_command cmd;
-		u32 readcmd, writecmd, status = 0;
+		u32 readcmd, writecmd;
 
 		memset(&brq, 0, sizeof(struct mmc_blk_request));
 		brq.mrq.cmd = &brq.cmd;
@@ -251,14 +236,6 @@
 		brq.stop.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
 		brq.data.blocks = req->nr_sectors;
 
-		/*
-		 * After a read error, we redo the request one sector at a time
-		 * in order to accurately determine which sectors can be read
-		 * successfully.
-		 */
-		if (disable_multi && brq.data.blocks > 1)
-			brq.data.blocks = 1;
-
 		if (brq.data.blocks > 1) {
 			/* SPI multiblock writes terminate using a special
 			 * token, not a STOP_TRANSMISSION request.
@@ -287,25 +264,6 @@
 		brq.data.sg = mq->sg;
 		brq.data.sg_len = mmc_queue_map_sg(mq);
 
-		/*
-		 * Adjust the sg list so it is the same size as the
-		 * request.
-		 */
-		if (brq.data.blocks != req->nr_sectors) {
-			int i, data_size = brq.data.blocks << 9;
-			struct scatterlist *sg;
-
-			for_each_sg(brq.data.sg, sg, brq.data.sg_len, i) {
-				data_size -= sg->length;
-				if (data_size <= 0) {
-					sg->length += data_size;
-					i++;
-					break;
-				}
-			}
-			brq.data.sg_len = i;
-		}
-
 		mmc_queue_bounce_pre(mq);
 
 		mmc_wait_for_req(card->host, &brq.mrq);
@@ -317,40 +275,19 @@
 		 * until later as we need to wait for the card to leave
 		 * programming mode even when things go wrong.
 		 */
-		if (brq.cmd.error || brq.data.error || brq.stop.error) {
-			if (brq.data.blocks > 1 && rq_data_dir(req) == READ) {
-				/* Redo read one sector at a time */
-				printk(KERN_WARNING "%s: retrying using single "
-				       "block read\n", req->rq_disk->disk_name);
-				disable_multi = 1;
-				continue;
-			}
-			status = get_card_status(card, req);
-		}
-
 		if (brq.cmd.error) {
-			printk(KERN_ERR "%s: error %d sending read/write "
-			       "command, response %#x, card status %#x\n",
-			       req->rq_disk->disk_name, brq.cmd.error,
-			       brq.cmd.resp[0], status);
+			printk(KERN_ERR "%s: error %d sending read/write command\n",
+			       req->rq_disk->disk_name, brq.cmd.error);
 		}
 
 		if (brq.data.error) {
-			if (brq.data.error == -ETIMEDOUT && brq.mrq.stop)
-				/* 'Stop' response contains card status */
-				status = brq.mrq.stop->resp[0];
-			printk(KERN_ERR "%s: error %d transferring data,"
-			       " sector %u, nr %u, card status %#x\n",
-			       req->rq_disk->disk_name, brq.data.error,
-			       (unsigned)req->sector,
-			       (unsigned)req->nr_sectors, status);
+			printk(KERN_ERR "%s: error %d transferring data\n",
+			       req->rq_disk->disk_name, brq.data.error);
 		}
 
 		if (brq.stop.error) {
-			printk(KERN_ERR "%s: error %d sending stop command, "
-			       "response %#x, card status %#x\n",
-			       req->rq_disk->disk_name, brq.stop.error,
-			       brq.stop.resp[0], status);
+			printk(KERN_ERR "%s: error %d sending stop command\n",
+			       req->rq_disk->disk_name, brq.stop.error);
 		}
 
 		if (!mmc_host_is_spi(card->host) && rq_data_dir(req) != READ) {
@@ -383,20 +320,8 @@
 #endif
 		}
 
-		if (brq.cmd.error || brq.stop.error || brq.data.error) {
-			if (rq_data_dir(req) == READ) {
-				/*
-				 * After an error, we redo I/O one sector at a
-				 * time, so we only reach here after trying to
-				 * read a single sector.
-				 */
-				spin_lock_irq(&md->lock);
-				ret = __blk_end_request(req, -EIO, brq.data.blksz);
-				spin_unlock_irq(&md->lock);
-				continue;
-			}
+		if (brq.cmd.error || brq.data.error || brq.stop.error)
 			goto cmd_err;
-		}
 
 		/*
 		 * A block was successfully transferred.
@@ -418,20 +343,25 @@
 	 * If the card is not SD, we can still ok written sectors
 	 * as reported by the controller (which might be less than
 	 * the real number of written sectors, but never more).
+	 *
+	 * For reads we just fail the entire chunk as that should
+	 * be safe in all cases.
 	 */
-	if (mmc_card_sd(card)) {
-		u32 blocks;
+	if (rq_data_dir(req) != READ) {
+		if (mmc_card_sd(card)) {
+			u32 blocks;
 
-		blocks = mmc_sd_num_wr_blocks(card);
-		if (blocks != (u32)-1) {
+			blocks = mmc_sd_num_wr_blocks(card);
+			if (blocks != (u32)-1) {
+				spin_lock_irq(&md->lock);
+				ret = __blk_end_request(req, 0, blocks << 9);
+				spin_unlock_irq(&md->lock);
+			}
+		} else {
 			spin_lock_irq(&md->lock);
-			ret = __blk_end_request(req, 0, blocks << 9);
+			ret = __blk_end_request(req, 0, brq.data.bytes_xfered);
 			spin_unlock_irq(&md->lock);
 		}
-	} else {
-		spin_lock_irq(&md->lock);
-		ret = __blk_end_request(req, 0, brq.data.bytes_xfered);
-		spin_unlock_irq(&md->lock);
 	}
 
 	mmc_release_host(card->host);
diff -ruN linux-02.01.03.11-org/drivers/mmc/core/core.c linux-02.01.03.11-new/drivers/mmc/core/core.c
--- linux-02.01.03.11-org/drivers/mmc/core/core.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/core/core.c	2010-01-18 20:34:31.000000000 +0800
@@ -20,7 +20,6 @@
 #include <linux/err.h>
 #include <linux/leds.h>
 #include <linux/scatterlist.h>
-#include <linux/log2.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -449,80 +448,6 @@
 	mmc_set_ios(host);
 }
 
-/**
- * mmc_vdd_to_ocrbitnum - Convert a voltage to the OCR bit number
- * @vdd:	voltage (mV)
- * @low_bits:	prefer low bits in boundary cases
- *
- * This function returns the OCR bit number according to the provided @vdd
- * value. If conversion is not possible a negative errno value returned.
- *
- * Depending on the @low_bits flag the function prefers low or high OCR bits
- * on boundary voltages. For example,
- * with @low_bits = true, 3300 mV translates to ilog2(MMC_VDD_32_33);
- * with @low_bits = false, 3300 mV translates to ilog2(MMC_VDD_33_34);
- *
- * Any value in the [1951:1999] range translates to the ilog2(MMC_VDD_20_21).
- */
-static int mmc_vdd_to_ocrbitnum(int vdd, bool low_bits)
-{
-	const int max_bit = ilog2(MMC_VDD_35_36);
-	int bit;
-
-	if (vdd < 1650 || vdd > 3600)
-		return -EINVAL;
-
-	if (vdd >= 1650 && vdd <= 1950)
-		return ilog2(MMC_VDD_165_195);
-
-	if (low_bits)
-		vdd -= 1;
-
-	/* Base 2000 mV, step 100 mV, bit's base 8. */
-	bit = (vdd - 2000) / 100 + 8;
-	if (bit > max_bit)
-		return max_bit;
-	return bit;
-}
-
-/**
- * mmc_vddrange_to_ocrmask - Convert a voltage range to the OCR mask
- * @vdd_min:	minimum voltage value (mV)
- * @vdd_max:	maximum voltage value (mV)
- *
- * This function returns the OCR mask bits according to the provided @vdd_min
- * and @vdd_max values. If conversion is not possible the function returns 0.
- *
- * Notes wrt boundary cases:
- * This function sets the OCR bits for all boundary voltages, for example
- * [3300:3400] range is translated to MMC_VDD_32_33 | MMC_VDD_33_34 |
- * MMC_VDD_34_35 mask.
- */
-u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max)
-{
-	u32 mask = 0;
-
-	if (vdd_max < vdd_min)
-		return 0;
-
-	/* Prefer high bits for the boundary vdd_max values. */
-	vdd_max = mmc_vdd_to_ocrbitnum(vdd_max, false);
-	if (vdd_max < 0)
-		return 0;
-
-	/* Prefer low bits for the boundary vdd_min values. */
-	vdd_min = mmc_vdd_to_ocrbitnum(vdd_min, true);
-	if (vdd_min < 0)
-		return 0;
-
-	/* Fill the mask, from max bit to min bit. */
-	while (vdd_max >= vdd_min)
-		mask |= 1 << vdd_max--;
-
-	return mask;
-}
-EXPORT_SYMBOL(mmc_vddrange_to_ocrmask);
-
 /*
  * Mask off any voltages we don't support and select
  * the lowest voltage
@@ -542,8 +467,6 @@
 		host->ios.vdd = bit;
 		mmc_set_ios(host);
 	} else {
-		pr_warning("%s: host doesn't support card's voltages\n",
-				mmc_hostname(host));
 		ocr = 0;
 	}
 
diff -ruN linux-02.01.03.11-org/drivers/mmc/core/mmc.c linux-02.01.03.11-new/drivers/mmc/core/mmc.c
--- linux-02.01.03.11-org/drivers/mmc/core/mmc.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/core/mmc.c	2010-01-18 20:34:31.000000000 +0800
@@ -434,24 +434,13 @@
 	 * Activate wide bus (if supported).
 	 */
 	if ((card->csd.mmca_vsn >= CSD_SPEC_VER_4) &&
-	    (host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA))) {
-		unsigned ext_csd_bit, bus_width;
-
-		if (host->caps & MMC_CAP_8_BIT_DATA) {
-			ext_csd_bit = EXT_CSD_BUS_WIDTH_8;
-			bus_width = MMC_BUS_WIDTH_8;
-		} else {
-			ext_csd_bit = EXT_CSD_BUS_WIDTH_4;
-			bus_width = MMC_BUS_WIDTH_4;
-		}
-
+		(host->caps & MMC_CAP_4_BIT_DATA)) {
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 EXT_CSD_BUS_WIDTH, ext_csd_bit);
-
+			EXT_CSD_BUS_WIDTH, EXT_CSD_BUS_WIDTH_4);
 		if (err)
 			goto free_card;
 
-		mmc_set_bus_width(card->host, bus_width);
+		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
 	}
 
 	if (!oldcard)
@@ -635,3 +624,4 @@
 
 	return err;
 }
+
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/at91_mci.c linux-02.01.03.11-new/drivers/mmc/host/at91_mci.c
--- linux-02.01.03.11-org/drivers/mmc/host/at91_mci.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/at91_mci.c	2010-01-18 20:34:31.000000000 +0800
@@ -1088,8 +1088,6 @@
 		goto fail0;
 	}
 
-	setup_timer(&host->timer, at91_timeout_timer, (unsigned long)host);
-
 	platform_set_drvdata(pdev, mmc);
 
 	/*
@@ -1103,6 +1101,8 @@
 
 	mmc_add_host(mmc);
 
+	setup_timer(&host->timer, at91_timeout_timer, (unsigned long)host);
+
 	/*
 	 * monitor card insertion/removal if we can
 	 */
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/atmel-mci.c linux-02.01.03.11-new/drivers/mmc/host/atmel-mci.c
--- linux-02.01.03.11-org/drivers/mmc/host/atmel-mci.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/atmel-mci.c	2010-01-18 20:34:31.000000000 +0800
@@ -25,8 +25,8 @@
 #include <linux/stat.h>
 
 #include <linux/mmc/host.h>
-#include <linux/atmel-mci.h>
 
+#include <asm/atmel-mci.h>
 #include <asm/io.h>
 #include <asm/unaligned.h>
 
@@ -55,6 +55,7 @@
 
 struct atmel_mci_dma {
 #ifdef CONFIG_MMC_ATMELMCI_DMA
+	struct dma_client		client;
 	struct dma_chan			*chan;
 	struct dma_async_tx_descriptor	*data_desc;
 #endif
@@ -592,8 +593,10 @@
 
 	/* If we don't have a channel, we can't do DMA */
 	chan = host->dma.chan;
-	if (chan)
+	if (chan) {
+		dma_chan_get(chan);
 		host->data_chan = chan;
+	}
 
 	if (!chan)
 		return -ENODEV;
@@ -1440,6 +1443,60 @@
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_MMC_ATMELMCI_DMA
+
+static inline struct atmel_mci *
+dma_client_to_atmel_mci(struct dma_client *client)
+{
+	return container_of(client, struct atmel_mci, dma.client);
+}
+
+static enum dma_state_client atmci_dma_event(struct dma_client *client,
+		struct dma_chan *chan, enum dma_state state)
+{
+	struct atmel_mci	*host;
+	enum dma_state_client	ret = DMA_NAK;
+
+	host = dma_client_to_atmel_mci(client);
+
+	switch (state) {
+	case DMA_RESOURCE_AVAILABLE:
+		spin_lock_bh(&host->lock);
+		if (!host->dma.chan) {
+			host->dma.chan = chan;
+			ret = DMA_ACK;
+		}
+		spin_unlock_bh(&host->lock);
+
+		if (ret == DMA_ACK)
+			dev_info(&host->pdev->dev,
+					"Using %s for DMA transfers\n",
+					chan->dev.bus_id);
+		break;
+
+	case DMA_RESOURCE_REMOVED:
+		spin_lock_bh(&host->lock);
+		if (host->dma.chan == chan) {
+			host->dma.chan = NULL;
+			ret = DMA_ACK;
+		}
+		spin_unlock_bh(&host->lock);
+
+		if (ret == DMA_ACK)
+			dev_info(&host->pdev->dev,
+					"Lost %s, falling back to PIO\n",
+					chan->dev.bus_id);
+		break;
+
+	default:
+		break;
+	}
+
+
+	return ret;
+}
+#endif /* CONFIG_MMC_ATMELMCI_DMA */
+
 static int __init atmci_init_slot(struct atmel_mci *host,
 		struct mci_slot_pdata *slot_data, unsigned int id,
 		u32 sdc_reg)
@@ -1543,18 +1600,6 @@
 	mmc_free_host(slot->mmc);
 }
 
-#ifdef CONFIG_MMC_ATMELMCI_DMA
-static bool filter(struct dma_chan *chan, void *slave)
-{
-	struct dw_dma_slave *dws = slave;
-
-	if (dws->dma_dev == chan->device->dev)
-		return true;
-	else
-		return false;
-}
-#endif
-
 static int __init atmci_probe(struct platform_device *pdev)
 {
 	struct mci_platform_data	*pdata;
@@ -1607,20 +1652,22 @@
 		goto err_request_irq;
 
 #ifdef CONFIG_MMC_ATMELMCI_DMA
-	if (pdata->dma_slave.dma_dev) {
-		struct dw_dma_slave *dws = &pdata->dma_slave;
-		dma_cap_mask_t mask;
+	if (pdata->dma_slave) {
+		struct dma_slave *slave = pdata->dma_slave;
 
-		dws->tx_reg = regs->start + MCI_TDR;
-		dws->rx_reg = regs->start + MCI_RDR;
+		slave->tx_reg = regs->start + MCI_TDR;
+		slave->rx_reg = regs->start + MCI_RDR;
 
 		/* Try to grab a DMA channel */
-		dma_cap_zero(mask);
-		dma_cap_set(DMA_SLAVE, mask);
-		host->dma.chan = dma_request_channel(mask, filter, dws);
-	}
-	if (!host->dma.chan)
+		host->dma.client.event_callback = atmci_dma_event;
+		dma_cap_set(DMA_SLAVE, host->dma.client.cap_mask);
+		host->dma.client.slave = slave;
+
+		dma_async_client_register(&host->dma.client);
+		dma_async_client_chan_request(&host->dma.client);
+	} else {
 		dev_notice(&pdev->dev, "DMA not available, using PIO\n");
+	}
 #endif /* CONFIG_MMC_ATMELMCI_DMA */
 
 	platform_set_drvdata(pdev, host);
@@ -1652,8 +1699,8 @@
 
 err_init_slot:
 #ifdef CONFIG_MMC_ATMELMCI_DMA
-	if (host->dma.chan)
-		dma_release_channel(host->dma.chan);
+	if (pdata->dma_slave)
+		dma_async_client_unregister(&host->dma.client);
 #endif
 	free_irq(irq, host);
 err_request_irq:
@@ -1684,8 +1731,8 @@
 	clk_disable(host->mck);
 
 #ifdef CONFIG_MMC_ATMELMCI_DMA
-	if (host->dma.chan)
-		dma_release_channel(host->dma.chan);
+	if (host->dma.client.slave)
+		dma_async_client_unregister(&host->dma.client);
 #endif
 
 	free_irq(platform_get_irq(pdev, 0), host);
@@ -1714,7 +1761,7 @@
 	platform_driver_unregister(&atmci_driver);
 }
 
-late_initcall(atmci_init); /* try to load after dma driver when built-in */
+module_init(atmci_init);
 module_exit(atmci_exit);
 
 MODULE_DESCRIPTION("Atmel Multimedia Card Interface driver");
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/imxmmc.c linux-02.01.03.11-new/drivers/mmc/host/imxmmc.c
--- linux-02.01.03.11-org/drivers/mmc/host/imxmmc.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/imxmmc.c	2010-01-18 20:34:30.000000000 +0800
@@ -10,6 +10,20 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
+ *  2005-04-17 Pavel Pisa <pisa@cmp.felk.cvut.cz>
+ *             Changed to conform redesigned i.MX scatter gather DMA interface
+ *
+ *  2005-11-04 Pavel Pisa <pisa@cmp.felk.cvut.cz>
+ *             Updated for 2.6.14 kernel
+ *
+ *  2005-12-13 Jay Monkman <jtm@smoothsmoothie.com>
+ *             Found and corrected problems in the write path
+ *
+ *  2005-12-30 Pavel Pisa <pisa@cmp.felk.cvut.cz>
+ *             The event handling rewritten right way in softirq.
+ *             Added many ugly hacks and delays to overcome SDHC
+ *             deficiencies
+ *
  */
 
 #include <linux/module.h>
@@ -23,9 +37,9 @@
 #include <linux/mmc/card.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
-#include <linux/io.h>
 
 #include <asm/dma.h>
+#include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/sizes.h>
 #include <mach/mmc.h>
@@ -36,16 +50,17 @@
 #define DRIVER_NAME "imx-mmc"
 
 #define IMXMCI_INT_MASK_DEFAULT (INT_MASK_BUF_READY | INT_MASK_DATA_TRAN | \
-				 INT_MASK_WRITE_OP_DONE | INT_MASK_END_CMD_RES | \
-				 INT_MASK_AUTO_CARD_DETECT | INT_MASK_DAT0_EN | INT_MASK_SDIO)
+	              INT_MASK_WRITE_OP_DONE | INT_MASK_END_CMD_RES | \
+		      INT_MASK_AUTO_CARD_DETECT | INT_MASK_DAT0_EN | INT_MASK_SDIO)
 
 struct imxmci_host {
 	struct mmc_host		*mmc;
 	spinlock_t		lock;
 	struct resource		*res;
-	void __iomem		*base;
 	int			irq;
 	imx_dmach_t		dma;
+	unsigned int		clkrt;
+	unsigned int		cmdat;
 	volatile unsigned int	imask;
 	unsigned int		power_mode;
 	unsigned int		present;
@@ -59,7 +74,7 @@
 	struct tasklet_struct	tasklet;
 	unsigned int		status_reg;
 	unsigned long		pending_events;
-	/* Next two fields are there for CPU driven transfers to overcome SDHC deficiencies */
+	/* Next to fields are there for CPU driven transfers to overcome SDHC deficiencies */
 	u16			*data_ptr;
 	unsigned int		data_cnt;
 	atomic_t		stuck_timeout;
@@ -99,22 +114,14 @@
 static void imxmci_stop_clock(struct imxmci_host *host)
 {
 	int i = 0;
-	u16 reg;
+	MMC_STR_STP_CLK &= ~STR_STP_CLK_START_CLK;
+	while(i < 0x1000) {
+	        if(!(i & 0x7f))
+			MMC_STR_STP_CLK |= STR_STP_CLK_STOP_CLK;
 
-	reg = readw(host->base + MMC_REG_STR_STP_CLK);
-	writew(reg & ~STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);
-	while (i < 0x1000) {
-		if (!(i & 0x7f)) {
-			reg = readw(host->base + MMC_REG_STR_STP_CLK);
-			writew(reg | STR_STP_CLK_STOP_CLK,
-					host->base + MMC_REG_STR_STP_CLK);
-		}
-
-		reg = readw(host->base + MMC_REG_STATUS);
-		if (!(reg & STATUS_CARD_BUS_CLK_RUN)) {
+		if(!(MMC_STATUS & STATUS_CARD_BUS_CLK_RUN)) {
 			/* Check twice before cut */
-			reg = readw(host->base + MMC_REG_STATUS);
-			if (!(reg & STATUS_CARD_BUS_CLK_RUN))
+			if(!(MMC_STATUS & STATUS_CARD_BUS_CLK_RUN))
 				return;
 		}
 
@@ -128,10 +135,8 @@
 	unsigned int trials = 0;
 	unsigned int delay_limit = 128;
 	unsigned long flags;
-	u16 reg;
 
-	reg = readw(host->base + MMC_REG_STR_STP_CLK);
-	writew(reg & ~STR_STP_CLK_STOP_CLK, host->base + MMC_REG_STR_STP_CLK);
+	MMC_STR_STP_CLK &= ~STR_STP_CLK_STOP_CLK;
 
 	clear_bit(IMXMCI_PEND_STARTED_b, &host->pending_events);
 
@@ -140,21 +145,18 @@
 	 * then 6 delay loops, but during card detection (low clockrate)
 	 * it takes up to 5000 delay loops and sometimes fails for the first time
 	 */
-	reg = readw(host->base + MMC_REG_STR_STP_CLK);
-	writew(reg | STR_STP_CLK_START_CLK, host->base + MMC_REG_STR_STP_CLK);
+	MMC_STR_STP_CLK |= STR_STP_CLK_START_CLK;
 
 	do {
 		unsigned int delay = delay_limit;
 
-		while (delay--) {
-			reg = readw(host->base + MMC_REG_STATUS);
-			if (reg & STATUS_CARD_BUS_CLK_RUN)
+		while(delay--){
+			if(MMC_STATUS & STATUS_CARD_BUS_CLK_RUN)
 				/* Check twice before cut */
-				reg = readw(host->base + MMC_REG_STATUS);
-				if (reg & STATUS_CARD_BUS_CLK_RUN)
+				if(MMC_STATUS & STATUS_CARD_BUS_CLK_RUN)
 					return 0;
 
-			if (test_bit(IMXMCI_PEND_STARTED_b, &host->pending_events))
+			if(test_bit(IMXMCI_PEND_STARTED_b, &host->pending_events))
 				return 0;
 		}
 
@@ -165,59 +167,58 @@
 		 * IRQ or schedule delays this function execution and the clocks has
 		 * been already stopped by other means (response processing, SDHC HW)
 		 */
-		if (!test_bit(IMXMCI_PEND_STARTED_b, &host->pending_events)) {
-			reg = readw(host->base + MMC_REG_STR_STP_CLK);
-			writew(reg | STR_STP_CLK_START_CLK,
-					host->base + MMC_REG_STR_STP_CLK);
-		}
+		if(!test_bit(IMXMCI_PEND_STARTED_b, &host->pending_events))
+			MMC_STR_STP_CLK |= STR_STP_CLK_START_CLK;
 		local_irq_restore(flags);
 
-	} while (++trials < 256);
+	} while(++trials<256);
 
 	dev_err(mmc_dev(host->mmc), "imxmci_start_clock blocked, no luck\n");
 
 	return -1;
 }
 
-static void imxmci_softreset(struct imxmci_host *host)
+static void imxmci_softreset(void)
 {
-	int i;
-
 	/* reset sequence */
-	writew(0x08, host->base + MMC_REG_STR_STP_CLK);
-	writew(0x0D, host->base + MMC_REG_STR_STP_CLK);
-
-	for (i = 0; i < 8; i++)
-		writew(0x05, host->base + MMC_REG_STR_STP_CLK);
-
-	writew(0xff, host->base + MMC_REG_RES_TO);
-	writew(512, host->base + MMC_REG_BLK_LEN);
-	writew(1, host->base + MMC_REG_NOB);
+	MMC_STR_STP_CLK = 0x8;
+	MMC_STR_STP_CLK = 0xD;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+	MMC_STR_STP_CLK = 0x5;
+
+	MMC_RES_TO = 0xff;
+	MMC_BLK_LEN = 512;
+	MMC_NOB = 1;
 }
 
 static int imxmci_busy_wait_for_status(struct imxmci_host *host,
-				       unsigned int *pstat, unsigned int stat_mask,
-				       int timeout, const char *where)
+			unsigned int *pstat, unsigned int stat_mask,
+			int timeout, const char *where)
 {
-	int loops = 0;
-
-	while (!(*pstat & stat_mask)) {
-		loops += 2;
-		if (loops >= timeout) {
+	int loops=0;
+	while(!(*pstat & stat_mask)) {
+		loops+=2;
+		if(loops >= timeout) {
 			dev_dbg(mmc_dev(host->mmc), "busy wait timeout in %s, STATUS = 0x%x (0x%x)\n",
 				where, *pstat, stat_mask);
 			return -1;
 		}
 		udelay(2);
-		*pstat |= readw(host->base + MMC_REG_STATUS);
+		*pstat |= MMC_STATUS;
 	}
-	if (!loops)
+	if(!loops)
 		return 0;
 
 	/* The busy-wait is expected there for clock <8MHz due to SDHC hardware flaws */
-	if (!(stat_mask & STATUS_END_CMD_RESP) || (host->mmc->ios.clock >= 8000000))
+	if(!(stat_mask & STATUS_END_CMD_RESP) || (host->mmc->ios.clock>=8000000))
 		dev_info(mmc_dev(host->mmc), "busy wait for %d usec in %s, STATUS = 0x%x (0x%x)\n",
-			 loops, where, *pstat, stat_mask);
+			loops, where, *pstat, stat_mask);
 	return loops;
 }
 
@@ -234,8 +235,8 @@
 	host->data = data;
 	data->bytes_xfered = 0;
 
-	writew(nob, host->base + MMC_REG_NOB);
-	writew(blksz, host->base + MMC_REG_BLK_LEN);
+	MMC_NOB = nob;
+	MMC_BLK_LEN = blksz;
 
 	/*
 	 * DMA cannot be used for small block sizes, we have to use CPU driven transfers otherwise.
@@ -251,14 +252,14 @@
 			host->dma_dir = DMA_FROM_DEVICE;
 
 			/* Hack to enable read SCR */
-			writew(1, host->base + MMC_REG_NOB);
-			writew(512, host->base + MMC_REG_BLK_LEN);
+			MMC_NOB = 1;
+			MMC_BLK_LEN = 512;
 		} else {
 			host->dma_dir = DMA_TO_DEVICE;
 		}
 
 		/* Convert back to virtual address */
-		host->data_ptr = (u16 *)sg_virt(data->sg);
+		host->data_ptr = (u16*)sg_virt(data->sg);
 		host->data_cnt = 0;
 
 		clear_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events);
@@ -270,11 +271,10 @@
 	if (data->flags & MMC_DATA_READ) {
 		host->dma_dir = DMA_FROM_DEVICE;
 		host->dma_nents = dma_map_sg(mmc_dev(host->mmc), data->sg,
-					     data->sg_len,  host->dma_dir);
+						data->sg_len,  host->dma_dir);
 
 		imx_dma_setup_sg(host->dma, data->sg, data->sg_len, datasz,
-				 host->res->start + MMC_REG_BUFFER_ACCESS,
-				 DMA_MODE_READ);
+			host->res->start + MMC_BUFFER_ACCESS_OFS, DMA_MODE_READ);
 
 		/*imx_dma_setup_mem2dev_ccr(host->dma, DMA_MODE_READ, IMX_DMA_WIDTH_16, CCR_REN);*/
 		CCR(host->dma) = CCR_DMOD_LINEAR | CCR_DSIZ_32 | CCR_SMOD_FIFO | CCR_SSIZ_16 | CCR_REN;
@@ -282,11 +282,10 @@
 		host->dma_dir = DMA_TO_DEVICE;
 
 		host->dma_nents = dma_map_sg(mmc_dev(host->mmc), data->sg,
-					     data->sg_len,  host->dma_dir);
+						data->sg_len,  host->dma_dir);
 
 		imx_dma_setup_sg(host->dma, data->sg, data->sg_len, datasz,
-				 host->res->start + MMC_REG_BUFFER_ACCESS,
-				 DMA_MODE_WRITE);
+			host->res->start + MMC_BUFFER_ACCESS_OFS, DMA_MODE_WRITE);
 
 		/*imx_dma_setup_mem2dev_ccr(host->dma, DMA_MODE_WRITE, IMX_DMA_WIDTH_16, CCR_REN);*/
 		CCR(host->dma) = CCR_SMOD_LINEAR | CCR_SSIZ_32 | CCR_DMOD_FIFO | CCR_DSIZ_16 | CCR_REN;
@@ -294,12 +293,12 @@
 
 #if 1	/* This code is there only for consistency checking and can be disabled in future */
 	host->dma_size = 0;
-	for (i = 0; i < host->dma_nents; i++)
-		host->dma_size += data->sg[i].length;
+	for(i=0; i<host->dma_nents; i++)
+		host->dma_size+=data->sg[i].length;
 
 	if (datasz > host->dma_size) {
 		dev_err(mmc_dev(host->mmc), "imxmci_setup_data datasz 0x%x > 0x%x dm_size\n",
-			datasz, host->dma_size);
+		       datasz, host->dma_size);
 	}
 #endif
 
@@ -307,7 +306,7 @@
 
 	wmb();
 
-	if (host->actual_bus_width == MMC_BUS_WIDTH_4)
+	if(host->actual_bus_width == MMC_BUS_WIDTH_4)
 		BLR(host->dma) = 0;	/* burst 64 byte read / 64 bytes write */
 	else
 		BLR(host->dma) = 16;	/* burst 16 byte read / 16 bytes write */
@@ -318,8 +317,9 @@
 	clear_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events);
 
 	/* start DMA engine for read, write is delayed after initial response */
-	if (host->dma_dir == DMA_FROM_DEVICE)
+	if (host->dma_dir == DMA_FROM_DEVICE) {
 		imx_dma_enable(host->dma);
+	}
 }
 
 static void imxmci_start_cmd(struct imxmci_host *host, struct mmc_command *cmd, unsigned int cmdat)
@@ -351,16 +351,16 @@
 		break;
 	}
 
-	if (test_and_clear_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events))
+	if ( test_and_clear_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events) )
 		cmdat |= CMD_DAT_CONT_INIT; /* This command needs init */
 
-	if (host->actual_bus_width == MMC_BUS_WIDTH_4)
+	if ( host->actual_bus_width == MMC_BUS_WIDTH_4 )
 		cmdat |= CMD_DAT_CONT_BUS_WIDTH_4;
 
-	writew(cmd->opcode, host->base + MMC_REG_CMD);
-	writew(cmd->arg >> 16, host->base + MMC_REG_ARGH);
-	writew(cmd->arg & 0xffff, host->base + MMC_REG_ARGL);
-	writew(cmdat, host->base + MMC_REG_CMD_DAT_CONT);
+	MMC_CMD = cmd->opcode;
+	MMC_ARGH = cmd->arg >> 16;
+	MMC_ARGL = cmd->arg & 0xffff;
+	MMC_CMD_DAT_CONT = cmdat;
 
 	atomic_set(&host->stuck_timeout, 0);
 	set_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events);
@@ -368,18 +368,18 @@
 
 	imask = IMXMCI_INT_MASK_DEFAULT;
 	imask &= ~INT_MASK_END_CMD_RES;
-	if (cmdat & CMD_DAT_CONT_DATA_ENABLE) {
-		/* imask &= ~INT_MASK_BUF_READY; */
+	if ( cmdat & CMD_DAT_CONT_DATA_ENABLE ) {
+		/*imask &= ~INT_MASK_BUF_READY;*/
 		imask &= ~INT_MASK_DATA_TRAN;
-		if (cmdat & CMD_DAT_CONT_WRITE)
+		if ( cmdat & CMD_DAT_CONT_WRITE )
 			imask &= ~INT_MASK_WRITE_OP_DONE;
-		if (test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events))
+		if(test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events))
 			imask &= ~INT_MASK_BUF_READY;
 	}
 
 	spin_lock_irqsave(&host->lock, flags);
 	host->imask = imask;
-	writew(host->imask, host->base + MMC_REG_INT_MASK);
+	MMC_INT_MASK = host->imask;
 	spin_unlock_irqrestore(&host->lock, flags);
 
 	dev_dbg(mmc_dev(host->mmc), "CMD%02d (0x%02x) mask set to 0x%04x\n",
@@ -395,14 +395,14 @@
 	spin_lock_irqsave(&host->lock, flags);
 
 	host->pending_events &= ~(IMXMCI_PEND_WAIT_RESP_m | IMXMCI_PEND_DMA_END_m |
-				  IMXMCI_PEND_DMA_DATA_m | IMXMCI_PEND_CPU_DATA_m);
+			IMXMCI_PEND_DMA_DATA_m | IMXMCI_PEND_CPU_DATA_m);
 
 	host->imask = IMXMCI_INT_MASK_DEFAULT;
-	writew(host->imask, host->base + MMC_REG_INT_MASK);
+	MMC_INT_MASK = host->imask;
 
 	spin_unlock_irqrestore(&host->lock, flags);
 
-	if (req && req->cmd)
+	if(req && req->cmd)
 		host->prev_cmd_code = req->cmd->opcode;
 
 	host->req = NULL;
@@ -416,17 +416,17 @@
 	struct mmc_data *data = host->data;
 	int data_error;
 
-	if (test_and_clear_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events)) {
+	if(test_and_clear_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events)){
 		imx_dma_disable(host->dma);
 		dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->dma_nents,
 			     host->dma_dir);
 	}
 
-	if (stat & STATUS_ERR_MASK) {
-		dev_dbg(mmc_dev(host->mmc), "request failed. status: 0x%08x\n", stat);
-		if (stat & (STATUS_CRC_READ_ERR | STATUS_CRC_WRITE_ERR))
+	if ( stat & STATUS_ERR_MASK ) {
+		dev_dbg(mmc_dev(host->mmc), "request failed. status: 0x%08x\n",stat);
+		if(stat & (STATUS_CRC_READ_ERR | STATUS_CRC_WRITE_ERR))
 			data->error = -EILSEQ;
-		else if (stat & STATUS_TIME_OUT_READ)
+		else if(stat & STATUS_TIME_OUT_READ)
 			data->error = -ETIMEDOUT;
 		else
 			data->error = -EIO;
@@ -445,7 +445,7 @@
 {
 	struct mmc_command *cmd = host->cmd;
 	int i;
-	u32 a, b, c;
+	u32 a,b,c;
 	struct mmc_data *data = host->data;
 
 	if (!cmd)
@@ -461,18 +461,18 @@
 		cmd->error = -EILSEQ;
 	}
 
-	if (cmd->flags & MMC_RSP_PRESENT) {
-		if (cmd->flags & MMC_RSP_136) {
+	if(cmd->flags & MMC_RSP_PRESENT) {
+		if(cmd->flags & MMC_RSP_136) {
 			for (i = 0; i < 4; i++) {
-				a = readw(host->base + MMC_REG_RES_FIFO);
-				b = readw(host->base + MMC_REG_RES_FIFO);
-				cmd->resp[i] = a << 16 | b;
+				u32 a = MMC_RES_FIFO & 0xffff;
+				u32 b = MMC_RES_FIFO & 0xffff;
+				cmd->resp[i] = a<<16 | b;
 			}
 		} else {
-			a = readw(host->base + MMC_REG_RES_FIFO);
-			b = readw(host->base + MMC_REG_RES_FIFO);
-			c = readw(host->base + MMC_REG_RES_FIFO);
-			cmd->resp[0] = a << 24 | b << 8 | c >> 8;
+			a = MMC_RES_FIFO & 0xffff;
+			b = MMC_RES_FIFO & 0xffff;
+			c = MMC_RES_FIFO & 0xffff;
+			cmd->resp[0] = a<<24 | b<<8 | c>>8;
 		}
 	}
 
@@ -484,34 +484,36 @@
 
 			/* Wait for FIFO to be empty before starting DMA write */
 
-			stat = readw(host->base + MMC_REG_STATUS);
-			if (imxmci_busy_wait_for_status(host, &stat,
-							STATUS_APPL_BUFF_FE,
-							40, "imxmci_cmd_done DMA WR") < 0) {
+			stat = MMC_STATUS;
+			if(imxmci_busy_wait_for_status(host, &stat,
+				STATUS_APPL_BUFF_FE,
+				40, "imxmci_cmd_done DMA WR") < 0) {
 				cmd->error = -EIO;
 				imxmci_finish_data(host, stat);
-				if (host->req)
+				if(host->req)
 					imxmci_finish_request(host, host->req);
 				dev_warn(mmc_dev(host->mmc), "STATUS = 0x%04x\n",
-					 stat);
+				       stat);
 				return 0;
 			}
 
-			if (test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events))
+			if(test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events)) {
 				imx_dma_enable(host->dma);
+			}
 		}
 	} else {
 		struct mmc_request *req;
 		imxmci_stop_clock(host);
 		req = host->req;
 
-		if (data)
+		if(data)
 			imxmci_finish_data(host, stat);
 
-		if (req)
+		if( req ) {
 			imxmci_finish_request(host, req);
-		else
+		} else {
 			dev_warn(mmc_dev(host->mmc), "imxmci_cmd_done: no request to finish\n");
+		}
 	}
 
 	return 1;
@@ -533,10 +535,11 @@
 	} else {
 		struct mmc_request *req;
 		req = host->req;
-		if (req)
+		if( req ) {
 			imxmci_finish_request(host, req);
-		else
+		} else {
 			dev_warn(mmc_dev(host->mmc), "imxmci_data_done: no request to finish\n");
+		}
 	}
 
 	return 1;
@@ -549,7 +552,7 @@
 	int trans_done = 0;
 	unsigned int stat = *pstat;
 
-	if (host->actual_bus_width != MMC_BUS_WIDTH_4)
+	if(host->actual_bus_width != MMC_BUS_WIDTH_4)
 		burst_len = 16;
 	else
 		burst_len = 64;
@@ -560,44 +563,44 @@
 
 	udelay(20);	/* required for clocks < 8MHz*/
 
-	if (host->dma_dir == DMA_FROM_DEVICE) {
+	if(host->dma_dir == DMA_FROM_DEVICE) {
 		imxmci_busy_wait_for_status(host, &stat,
-					    STATUS_APPL_BUFF_FF | STATUS_DATA_TRANS_DONE |
-					    STATUS_TIME_OUT_READ,
-					    50, "imxmci_cpu_driven_data read");
-
-		while ((stat & (STATUS_APPL_BUFF_FF | STATUS_DATA_TRANS_DONE)) &&
-		       !(stat & STATUS_TIME_OUT_READ) &&
-		       (host->data_cnt < 512)) {
+				STATUS_APPL_BUFF_FF | STATUS_DATA_TRANS_DONE |
+				STATUS_TIME_OUT_READ,
+				50, "imxmci_cpu_driven_data read");
+
+		while((stat & (STATUS_APPL_BUFF_FF |  STATUS_DATA_TRANS_DONE)) &&
+		      !(stat & STATUS_TIME_OUT_READ) &&
+		      (host->data_cnt < 512)) {
 
 			udelay(20);	/* required for clocks < 8MHz*/
 
-			for (i = burst_len; i >= 2 ; i -= 2) {
+			for(i = burst_len; i>=2 ; i-=2) {
 				u16 data;
-				data = readw(host->base + MMC_REG_BUFFER_ACCESS);
+				data = MMC_BUFFER_ACCESS;
 				udelay(10);	/* required for clocks < 8MHz*/
-				if (host->data_cnt+2 <= host->dma_size) {
+				if(host->data_cnt+2 <= host->dma_size) {
 					*(host->data_ptr++) = data;
 				} else {
-					if (host->data_cnt < host->dma_size)
-						*(u8 *)(host->data_ptr) = data;
+					if(host->data_cnt < host->dma_size)
+						*(u8*)(host->data_ptr) = data;
 				}
 				host->data_cnt += 2;
 			}
 
-			stat = readw(host->base + MMC_REG_STATUS);
+			stat = MMC_STATUS;
 
 			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data read %d burst %d STATUS = 0x%x\n",
 				host->data_cnt, burst_len, stat);
 		}
 
-		if ((stat & STATUS_DATA_TRANS_DONE) && (host->data_cnt >= 512))
+		if((stat & STATUS_DATA_TRANS_DONE) && (host->data_cnt >= 512))
 			trans_done = 1;
 
-		if (host->dma_size & 0x1ff)
+		if(host->dma_size & 0x1ff)
 			stat &= ~STATUS_CRC_READ_ERR;
 
-		if (stat & STATUS_TIME_OUT_READ) {
+		if(stat & STATUS_TIME_OUT_READ) {
 			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data read timeout STATUS = 0x%x\n",
 				stat);
 			trans_done = -1;
@@ -605,12 +608,12 @@
 
 	} else {
 		imxmci_busy_wait_for_status(host, &stat,
-					    STATUS_APPL_BUFF_FE,
-					    20, "imxmci_cpu_driven_data write");
+				STATUS_APPL_BUFF_FE,
+				20, "imxmci_cpu_driven_data write");
 
-		while ((stat & STATUS_APPL_BUFF_FE) &&
-		       (host->data_cnt < host->dma_size)) {
-			if (burst_len >= host->dma_size - host->data_cnt) {
+		while((stat & STATUS_APPL_BUFF_FE) &&
+		      (host->data_cnt < host->dma_size)) {
+			if(burst_len >= host->dma_size - host->data_cnt) {
 				burst_len = host->dma_size - host->data_cnt;
 				host->data_cnt = host->dma_size;
 				trans_done = 1;
@@ -618,10 +621,10 @@
 				host->data_cnt += burst_len;
 			}
 
-			for (i = burst_len; i > 0 ; i -= 2)
-				writew(*(host->data_ptr++), host->base + MMC_REG_BUFFER_ACCESS);
+			for(i = burst_len; i>0 ; i-=2)
+				MMC_BUFFER_ACCESS = *(host->data_ptr++);
 
-			stat = readw(host->base + MMC_REG_STATUS);
+			stat = MMC_STATUS;
 
 			dev_dbg(mmc_dev(host->mmc), "imxmci_cpu_driven_data write burst %d STATUS = 0x%x\n",
 				burst_len, stat);
@@ -636,7 +639,7 @@
 static void imxmci_dma_irq(int dma, void *devid)
 {
 	struct imxmci_host *host = devid;
-	u32 stat = readw(host->base + MMC_REG_STATUS);
+	uint32_t stat = MMC_STATUS;
 
 	atomic_set(&host->stuck_timeout, 0);
 	host->status_reg = stat;
@@ -647,11 +650,10 @@
 static irqreturn_t imxmci_irq(int irq, void *devid)
 {
 	struct imxmci_host *host = devid;
-	u32 stat = readw(host->base + MMC_REG_STATUS);
+	uint32_t stat = MMC_STATUS;
 	int handled = 1;
 
-	writew(host->imask | INT_MASK_SDIO | INT_MASK_AUTO_CARD_DETECT,
-			host->base + MMC_REG_INT_MASK);
+	MMC_INT_MASK = host->imask | INT_MASK_SDIO | INT_MASK_AUTO_CARD_DETECT;
 
 	atomic_set(&host->stuck_timeout, 0);
 	host->status_reg = stat;
@@ -669,10 +671,10 @@
 	unsigned int data_dir_mask = 0;	/* STATUS_WR_CRC_ERROR_CODE_MASK */
 	int timeout = 0;
 
-	if (atomic_read(&host->stuck_timeout) > 4) {
+	if(atomic_read(&host->stuck_timeout) > 4) {
 		char *what;
 		timeout = 1;
-		stat = readw(host->base + MMC_REG_STATUS);
+		stat = MMC_STATUS;
 		host->status_reg = stat;
 		if (test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))
 			if (test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events))
@@ -681,37 +683,29 @@
 				what = "RESP";
 		else
 			if (test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events))
-				if (test_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events))
+				if(test_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events))
 					what = "DATA";
 				else
 					what = "DMA";
 			else
 				what = "???";
 
-		dev_err(mmc_dev(host->mmc),
-			"%s TIMEOUT, hardware stucked STATUS = 0x%04x IMASK = 0x%04x\n",
-			what, stat,
-			readw(host->base + MMC_REG_INT_MASK));
-		dev_err(mmc_dev(host->mmc),
-			"CMD_DAT_CONT = 0x%04x, MMC_BLK_LEN = 0x%04x, MMC_NOB = 0x%04x, DMA_CCR = 0x%08x\n",
-			readw(host->base + MMC_REG_CMD_DAT_CONT),
-			readw(host->base + MMC_REG_BLK_LEN),
-			readw(host->base + MMC_REG_NOB),
-			CCR(host->dma));
+		dev_err(mmc_dev(host->mmc), "%s TIMEOUT, hardware stucked STATUS = 0x%04x IMASK = 0x%04x\n",
+		       what, stat, MMC_INT_MASK);
+		dev_err(mmc_dev(host->mmc), "CMD_DAT_CONT = 0x%04x, MMC_BLK_LEN = 0x%04x, MMC_NOB = 0x%04x, DMA_CCR = 0x%08x\n",
+		       MMC_CMD_DAT_CONT, MMC_BLK_LEN, MMC_NOB, CCR(host->dma));
 		dev_err(mmc_dev(host->mmc), "CMD%d, prevCMD%d, bus %d-bit, dma_size = 0x%x\n",
-			host->cmd ? host->cmd->opcode : 0,
-			host->prev_cmd_code,
-			1 << host->actual_bus_width, host->dma_size);
+		       host->cmd?host->cmd->opcode:0, host->prev_cmd_code, 1<<host->actual_bus_width, host->dma_size);
 	}
 
-	if (!host->present || timeout)
+	if(!host->present || timeout)
 		host->status_reg = STATUS_TIME_OUT_RESP | STATUS_TIME_OUT_READ |
-			STATUS_CRC_READ_ERR | STATUS_CRC_WRITE_ERR;
+				    STATUS_CRC_READ_ERR | STATUS_CRC_WRITE_ERR;
 
-	if (test_bit(IMXMCI_PEND_IRQ_b, &host->pending_events) || timeout) {
+	if(test_bit(IMXMCI_PEND_IRQ_b, &host->pending_events) || timeout) {
 		clear_bit(IMXMCI_PEND_IRQ_b, &host->pending_events);
 
-		stat = readw(host->base + MMC_REG_STATUS);
+		stat = MMC_STATUS;
 		/*
 		 * This is not required in theory, but there is chance to miss some flag
 		 * which clears automatically by mask write, FreeScale original code keeps
@@ -719,62 +713,63 @@
 		 */
 		stat |= host->status_reg;
 
-		if (test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events))
+		if(test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events))
 			stat &= ~STATUS_CRC_READ_ERR;
 
-		if (test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events)) {
+		if(test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events)) {
 			imxmci_busy_wait_for_status(host, &stat,
-						    STATUS_END_CMD_RESP | STATUS_ERR_MASK,
-						    20, "imxmci_tasklet_fnc resp (ERRATUM #4)");
+					STATUS_END_CMD_RESP | STATUS_ERR_MASK,
+					20, "imxmci_tasklet_fnc resp (ERRATUM #4)");
 		}
 
-		if (stat & (STATUS_END_CMD_RESP | STATUS_ERR_MASK)) {
-			if (test_and_clear_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))
+		if(stat & (STATUS_END_CMD_RESP | STATUS_ERR_MASK)) {
+			if(test_and_clear_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))
 				imxmci_cmd_done(host, stat);
-			if (host->data && (stat & STATUS_ERR_MASK))
+			if(host->data && (stat & STATUS_ERR_MASK))
 				imxmci_data_done(host, stat);
 		}
 
-		if (test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events)) {
-			stat |= readw(host->base + MMC_REG_STATUS);
-			if (imxmci_cpu_driven_data(host, &stat)) {
-				if (test_and_clear_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))
+		if(test_bit(IMXMCI_PEND_CPU_DATA_b, &host->pending_events)) {
+			stat |= MMC_STATUS;
+			if(imxmci_cpu_driven_data(host, &stat)){
+				if(test_and_clear_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events))
 					imxmci_cmd_done(host, stat);
 				atomic_clear_mask(IMXMCI_PEND_IRQ_m|IMXMCI_PEND_CPU_DATA_m,
-						  &host->pending_events);
+							&host->pending_events);
 				imxmci_data_done(host, stat);
 			}
 		}
 	}
 
-	if (test_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events) &&
-	    !test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events)) {
+	if(test_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events) &&
+	   !test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events)) {
 
-		stat = readw(host->base + MMC_REG_STATUS);
+		stat = MMC_STATUS;
 		/* Same as above */
 		stat |= host->status_reg;
 
-		if (host->dma_dir == DMA_TO_DEVICE)
+		if(host->dma_dir == DMA_TO_DEVICE) {
 			data_dir_mask = STATUS_WRITE_OP_DONE;
-		else
+		} else {
 			data_dir_mask = STATUS_DATA_TRANS_DONE;
+		}
 
-		if (stat & data_dir_mask) {
+		if(stat & data_dir_mask) {
 			clear_bit(IMXMCI_PEND_DMA_END_b, &host->pending_events);
 			imxmci_data_done(host, stat);
 		}
 	}
 
-	if (test_and_clear_bit(IMXMCI_PEND_CARD_XCHG_b, &host->pending_events)) {
+	if(test_and_clear_bit(IMXMCI_PEND_CARD_XCHG_b, &host->pending_events)) {
 
-		if (host->cmd)
+		if(host->cmd)
 			imxmci_cmd_done(host, STATUS_TIME_OUT_RESP);
 
-		if (host->data)
+		if(host->data)
 			imxmci_data_done(host, STATUS_TIME_OUT_READ |
 					 STATUS_CRC_READ_ERR | STATUS_CRC_WRITE_ERR);
 
-		if (host->req)
+		if(host->req)
 			imxmci_finish_request(host, host->req);
 
 		mmc_detect_change(host->mmc, msecs_to_jiffies(100));
@@ -801,8 +796,9 @@
 		if (req->data->flags & MMC_DATA_WRITE)
 			cmdat |= CMD_DAT_CONT_WRITE;
 
-		if (req->data->flags & MMC_DATA_STREAM)
+		if (req->data->flags & MMC_DATA_STREAM) {
 			cmdat |= CMD_DAT_CONT_STREAM_BLOCK;
+		}
 	}
 
 	imxmci_start_cmd(host, req->cmd, cmdat);
@@ -815,37 +811,36 @@
 	struct imxmci_host *host = mmc_priv(mmc);
 	int prescaler;
 
-	if (ios->bus_width == MMC_BUS_WIDTH_4) {
+	if( ios->bus_width==MMC_BUS_WIDTH_4 ) {
 		host->actual_bus_width = MMC_BUS_WIDTH_4;
 		imx_gpio_mode(PB11_PF_SD_DAT3);
-	} else {
+	}else{
 		host->actual_bus_width = MMC_BUS_WIDTH_1;
 		imx_gpio_mode(GPIO_PORTB | GPIO_IN | GPIO_PUEN | 11);
 	}
 
-	if (host->power_mode != ios->power_mode) {
+	if ( host->power_mode != ios->power_mode ) {
 		switch (ios->power_mode) {
 		case MMC_POWER_OFF:
-			break;
+        		break;
 		case MMC_POWER_UP:
 			set_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events);
-			break;
+        		break;
 		case MMC_POWER_ON:
-			break;
+        		break;
 		}
 		host->power_mode = ios->power_mode;
 	}
 
-	if (ios->clock) {
+	if ( ios->clock ) {
 		unsigned int clk;
-		u16 reg;
 
 		/* The prescaler is 5 for PERCLK2 equal to 96MHz
 		 * then 96MHz / 5 = 19.2 MHz
 		 */
 		clk = clk_get_rate(host->clk);
-		prescaler = (clk + (CLK_RATE * 7) / 8) / CLK_RATE;
-		switch (prescaler) {
+		prescaler=(clk+(CLK_RATE*7)/8)/CLK_RATE;
+		switch(prescaler) {
 		case 0:
 		case 1:	prescaler = 0;
 			break;
@@ -863,29 +858,24 @@
 		dev_dbg(mmc_dev(host->mmc), "PERCLK2 %d MHz -> prescaler %d\n",
 			clk, prescaler);
 
-		for (clk = 0; clk < 8; clk++) {
+		for(clk=0; clk<8; clk++) {
 			int x;
-			x = CLK_RATE / (1 << clk);
-			if (x <= ios->clock)
+			x = CLK_RATE / (1<<clk);
+			if( x <= ios->clock)
 				break;
 		}
 
-		/* enable controller */
-		reg = readw(host->base + MMC_REG_STR_STP_CLK);
-		writew(reg | STR_STP_CLK_ENABLE,
-				host->base + MMC_REG_STR_STP_CLK);
+		MMC_STR_STP_CLK |= STR_STP_CLK_ENABLE; /* enable controller */
 
 		imxmci_stop_clock(host);
-		writew((prescaler << 3) | clk, host->base + MMC_REG_CLK_RATE);
+		MMC_CLK_RATE = (prescaler<<3) | clk;
 		/*
 		 * Under my understanding, clock should not be started there, because it would
 		 * initiate SDHC sequencer and send last or random command into card
 		 */
-		/* imxmci_start_clock(host); */
+		/*imxmci_start_clock(host);*/
 
-		dev_dbg(mmc_dev(host->mmc),
-			"MMC_CLK_RATE: 0x%08x\n",
-			readw(host->base + MMC_REG_CLK_RATE));
+		dev_dbg(mmc_dev(host->mmc), "MMC_CLK_RATE: 0x%08x\n", MMC_CLK_RATE);
 	} else {
 		imxmci_stop_clock(host);
 	}
@@ -925,10 +915,10 @@
 		tasklet_schedule(&host->tasklet);
 	}
 
-	if (test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events) ||
-	    test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events)) {
+	if(test_bit(IMXMCI_PEND_WAIT_RESP_b, &host->pending_events) ||
+	   test_bit(IMXMCI_PEND_DMA_DATA_b, &host->pending_events)) {
 		atomic_inc(&host->stuck_timeout);
-		if (atomic_read(&host->stuck_timeout) > 4)
+		if(atomic_read(&host->stuck_timeout) > 4)
 			tasklet_schedule(&host->tasklet);
 	} else {
 		atomic_set(&host->stuck_timeout, 0);
@@ -944,7 +934,6 @@
 	struct imxmci_host *host = NULL;
 	struct resource *r;
 	int ret = 0, irq;
-	u16 rev_no;
 
 	printk(KERN_INFO "i.MX mmc driver\n");
 
@@ -953,8 +942,7 @@
 	if (!r || irq < 0)
 		return -ENXIO;
 
-	r = request_mem_region(r->start, resource_size(r), pdev->name);
-	if (!r)
+	if (!request_mem_region(r->start, 0x100, pdev->name))
 		return -EBUSY;
 
 	mmc = mmc_alloc_host(sizeof(struct imxmci_host), &pdev->dev);
@@ -978,12 +966,6 @@
 	mmc->max_blk_count = 65535;
 
 	host = mmc_priv(mmc);
-	host->base = ioremap(r->start, resource_size(r));
-	if (!host->base) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
 	host->mmc = mmc;
 	host->dma_allocated = 0;
 	host->pdata = pdev->dev.platform_data;
@@ -1011,20 +993,18 @@
 	imx_gpio_mode(PB12_PF_SD_CLK);
 	imx_gpio_mode(PB13_PF_SD_CMD);
 
-	imxmci_softreset(host);
+	imxmci_softreset();
 
-	rev_no = readw(host->base + MMC_REG_REV_NO);
-	if (rev_no != 0x390) {
+	if ( MMC_REV_NO != 0x390 ) {
 		dev_err(mmc_dev(host->mmc), "wrong rev.no. 0x%08x. aborting.\n",
-			readw(host->base + MMC_REG_REV_NO));
+		        MMC_REV_NO);
 		goto out;
 	}
 
-	/* recommended in data sheet */
-	writew(0x2db4, host->base + MMC_REG_READ_TO);
+	MMC_READ_TO = 0x2db4; /* recommended in data sheet */
 
 	host->imask = IMXMCI_INT_MASK_DEFAULT;
-	writew(host->imask, host->base + MMC_REG_INT_MASK);
+	MMC_INT_MASK = host->imask;
 
 	host->dma = imx_dma_request_by_prio(DRIVER_NAME, DMA_PRIO_LOW);
 	if(host->dma < 0) {
@@ -1032,7 +1012,7 @@
 		ret = -EBUSY;
 		goto out;
 	}
-	host->dma_allocated = 1;
+	host->dma_allocated=1;
 	imx_dma_setup_handlers(host->dma, imxmci_dma_irq, NULL, host);
 
 	tasklet_init(&host->tasklet, imxmci_tasklet_fnc, (unsigned long)host);
@@ -1052,7 +1032,7 @@
 	host->timer.data = (unsigned long)host;
 	host->timer.function = imxmci_check_status;
 	add_timer(&host->timer);
-	mod_timer(&host->timer, jiffies + (HZ >> 1));
+	mod_timer(&host->timer, jiffies + (HZ>>1));
 
 	platform_set_drvdata(pdev, mmc);
 
@@ -1062,20 +1042,18 @@
 
 out:
 	if (host) {
-		if (host->dma_allocated) {
+		if(host->dma_allocated){
 			imx_dma_free(host->dma);
-			host->dma_allocated = 0;
+			host->dma_allocated=0;
 		}
 		if (host->clk) {
 			clk_disable(host->clk);
 			clk_put(host->clk);
 		}
-		if (host->base)
-			iounmap(host->base);
 	}
 	if (mmc)
 		mmc_free_host(mmc);
-	release_mem_region(r->start, resource_size(r));
+	release_mem_region(r->start, 0x100);
 	return ret;
 }
 
@@ -1094,10 +1072,9 @@
 		mmc_remove_host(mmc);
 
 		free_irq(host->irq, host);
-		iounmap(host->base);
-		if (host->dma_allocated) {
+		if(host->dma_allocated){
 			imx_dma_free(host->dma);
-			host->dma_allocated = 0;
+			host->dma_allocated=0;
 		}
 
 		tasklet_kill(&host->tasklet);
@@ -1105,7 +1082,7 @@
 		clk_disable(host->clk);
 		clk_put(host->clk);
 
-		release_mem_region(host->res->start, resource_size(host->res));
+		release_mem_region(host->res->start, 0x100);
 
 		mmc_free_host(mmc);
 	}
@@ -1132,7 +1109,7 @@
 
 	if (mmc) {
 		host = mmc_priv(mmc);
-		if (host)
+		if(host)
 			set_bit(IMXMCI_PEND_SET_INIT_b, &host->pending_events);
 		ret = mmc_resume_host(mmc);
 	}
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/imxmmc.h linux-02.01.03.11-new/drivers/mmc/host/imxmmc.h
--- linux-02.01.03.11-org/drivers/mmc/host/imxmmc.h	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/imxmmc.h	2010-01-18 20:34:30.000000000 +0800
@@ -1,21 +1,24 @@
-#define MMC_REG_STR_STP_CLK		0x00
-#define MMC_REG_STATUS			0x04
-#define MMC_REG_CLK_RATE		0x08
-#define MMC_REG_CMD_DAT_CONT		0x0C
-#define MMC_REG_RES_TO			0x10
-#define MMC_REG_READ_TO			0x14
-#define MMC_REG_BLK_LEN			0x18
-#define MMC_REG_NOB			0x1C
-#define MMC_REG_REV_NO			0x20
-#define MMC_REG_INT_MASK		0x24
-#define MMC_REG_CMD			0x28
-#define MMC_REG_ARGH			0x2C
-#define MMC_REG_ARGL			0x30
-#define MMC_REG_RES_FIFO		0x34
-#define MMC_REG_BUFFER_ACCESS		0x38
 
-#define STR_STP_CLK_IPG_CLK_GATE_DIS    (1<<15)
-#define STR_STP_CLK_IPG_PERCLK_GATE_DIS (1<<14)
+# define __REG16(x)	(*((volatile u16 *)IO_ADDRESS(x)))
+
+#define MMC_STR_STP_CLK  __REG16(IMX_MMC_BASE + 0x00)
+#define MMC_STATUS       __REG16(IMX_MMC_BASE + 0x04)
+#define MMC_CLK_RATE     __REG16(IMX_MMC_BASE + 0x08)
+#define MMC_CMD_DAT_CONT __REG16(IMX_MMC_BASE + 0x0C)
+#define MMC_RES_TO       __REG16(IMX_MMC_BASE + 0x10)
+#define MMC_READ_TO      __REG16(IMX_MMC_BASE + 0x14)
+#define MMC_BLK_LEN      __REG16(IMX_MMC_BASE + 0x18)
+#define MMC_NOB          __REG16(IMX_MMC_BASE + 0x1C)
+#define MMC_REV_NO       __REG16(IMX_MMC_BASE + 0x20)
+#define MMC_INT_MASK     __REG16(IMX_MMC_BASE + 0x24)
+#define MMC_CMD          __REG16(IMX_MMC_BASE + 0x28)
+#define MMC_ARGH         __REG16(IMX_MMC_BASE + 0x2C)
+#define MMC_ARGL         __REG16(IMX_MMC_BASE + 0x30)
+#define MMC_RES_FIFO     __REG16(IMX_MMC_BASE + 0x34)
+#define MMC_BUFFER_ACCESS __REG16(IMX_MMC_BASE + 0x38)
+#define MMC_BUFFER_ACCESS_OFS 0x38
+
+
 #define STR_STP_CLK_ENDIAN              (1<<5)
 #define STR_STP_CLK_RESET               (1<<3)
 #define STR_STP_CLK_ENABLE              (1<<2)
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/Kconfig linux-02.01.03.11-new/drivers/mmc/host/Kconfig
--- linux-02.01.03.11-org/drivers/mmc/host/Kconfig	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/Kconfig	2010-01-18 20:34:30.000000000 +0800
@@ -79,10 +79,11 @@
 
 config MMC_OMAP_HS
 	tristate "TI OMAP High Speed Multimedia Card Interface support"
-	depends on ARCH_OMAP2430 || ARCH_OMAP3
+	depends on (ARCH_OMAP2 && ARCH_OMAP2430) || ARCH_OMAP3
+	select TWL4030_CORE
 	help
 	  This selects the TI OMAP High Speed Multimedia card Interface.
-	  If you have an OMAP2430 or OMAP3 board with a Multimedia Card slot,
+	  If you have an OMAP2(2430) or OMAP3 board with a Multimedia Card slot,
 	  say Y or M here.
 
 	  If unsure, say N.
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/Makefile linux-02.01.03.11-new/drivers/mmc/host/Makefile
--- linux-02.01.03.11-org/drivers/mmc/host/Makefile	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/Makefile	2010-01-18 20:34:31.000000000 +0800
@@ -20,9 +20,6 @@
 obj-$(CONFIG_MMC_ATMELMCI)	+= atmel-mci.o
 obj-$(CONFIG_MMC_TIFM_SD)	+= tifm_sd.o
 obj-$(CONFIG_MMC_SPI)		+= mmc_spi.o
-ifeq ($(CONFIG_OF),y)
-obj-$(CONFIG_MMC_SPI)		+= of_mmc_spi.o
-endif
 obj-$(CONFIG_MMC_S3C)   	+= s3cmci.o
 obj-$(CONFIG_MMC_SDRICOH_CS)	+= sdricoh_cs.o
 obj-$(CONFIG_MMC_TMIO)		+= tmio_mmc.o
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/mmci.c linux-02.01.03.11-new/drivers/mmc/host/mmci.c
--- linux-02.01.03.11-org/drivers/mmc/host/mmci.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/mmci.c	2010-01-18 20:34:31.000000000 +0800
@@ -500,7 +500,7 @@
 	}
 
 	host = mmc_priv(mmc);
-	host->clk = clk_get(&dev->dev, NULL);
+	host->clk = clk_get(&dev->dev, "MCLK");
 	if (IS_ERR(host->clk)) {
 		ret = PTR_ERR(host->clk);
 		host->clk = NULL;
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/mmc_spi.c linux-02.01.03.11-new/drivers/mmc/host/mmc_spi.c
--- linux-02.01.03.11-org/drivers/mmc/host/mmc_spi.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/mmc_spi.c	2010-01-18 20:34:31.000000000 +0800
@@ -1285,7 +1285,7 @@
 	/* Platform data is used to hook up things like card sensing
 	 * and power switching gpios.
 	 */
-	host->pdata = mmc_spi_get_pdata(spi);
+	host->pdata = spi->dev.platform_data;
 	if (host->pdata)
 		mmc->ocr_avail = host->pdata->ocr_mask;
 	if (!mmc->ocr_avail) {
@@ -1368,7 +1368,6 @@
 
 fail_nobuf1:
 	mmc_free_host(mmc);
-	mmc_spi_put_pdata(spi);
 	dev_set_drvdata(&spi->dev, NULL);
 
 nomem:
@@ -1403,7 +1402,6 @@
 
 		spi->max_speed_hz = mmc->f_max;
 		mmc_free_host(mmc);
-		mmc_spi_put_pdata(spi);
 		dev_set_drvdata(&spi->dev, NULL);
 	}
 	return 0;
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/of_mmc_spi.c linux-02.01.03.11-new/drivers/mmc/host/of_mmc_spi.c
--- linux-02.01.03.11-org/drivers/mmc/host/of_mmc_spi.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/of_mmc_spi.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,149 +0,0 @@
-/*
- * OpenFirmware bindings for the MMC-over-SPI driver
- *
- * Copyright (c) MontaVista Software, Inc. 2008.
- *
- * Author: Anton Vorontsov <avorontsov@ru.mvista.com>
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/gpio.h>
-#include <linux/of.h>
-#include <linux/of_gpio.h>
-#include <linux/spi/spi.h>
-#include <linux/spi/mmc_spi.h>
-#include <linux/mmc/core.h>
-#include <linux/mmc/host.h>
-
-enum {
-	CD_GPIO = 0,
-	WP_GPIO,
-	NUM_GPIOS,
-};
-
-struct of_mmc_spi {
-	int gpios[NUM_GPIOS];
-	bool alow_gpios[NUM_GPIOS];
-	struct mmc_spi_platform_data pdata;
-};
-
-static struct of_mmc_spi *to_of_mmc_spi(struct device *dev)
-{
-	return container_of(dev->platform_data, struct of_mmc_spi, pdata);
-}
-
-static int of_mmc_spi_read_gpio(struct device *dev, int gpio_num)
-{
-	struct of_mmc_spi *oms = to_of_mmc_spi(dev);
-	bool active_low = oms->alow_gpios[gpio_num];
-	bool value = gpio_get_value(oms->gpios[gpio_num]);
-
-	return active_low ^ value;
-}
-
-static int of_mmc_spi_get_cd(struct device *dev)
-{
-	return of_mmc_spi_read_gpio(dev, CD_GPIO);
-}
-
-static int of_mmc_spi_get_ro(struct device *dev)
-{
-	return of_mmc_spi_read_gpio(dev, WP_GPIO);
-}
-
-struct mmc_spi_platform_data *mmc_spi_get_pdata(struct spi_device *spi)
-{
-	struct device *dev = &spi->dev;
-	struct device_node *np = dev_archdata_get_node(&dev->archdata);
-	struct of_mmc_spi *oms;
-	const u32 *voltage_ranges;
-	int num_ranges;
-	int i;
-	int ret = -EINVAL;
-
-	if (dev->platform_data || !np)
-		return dev->platform_data;
-
-	oms = kzalloc(sizeof(*oms), GFP_KERNEL);
-	if (!oms)
-		return NULL;
-
-	voltage_ranges = of_get_property(np, "voltage-ranges", &num_ranges);
-	num_ranges = num_ranges / sizeof(*voltage_ranges) / 2;
-	if (!voltage_ranges || !num_ranges) {
-		dev_err(dev, "OF: voltage-ranges unspecified\n");
-		goto err_ocr;
-	}
-
-	for (i = 0; i < num_ranges; i++) {
-		const int j = i * 2;
-		u32 mask;
-
-		mask = mmc_vddrange_to_ocrmask(voltage_ranges[j],
-					       voltage_ranges[j + 1]);
-		if (!mask) {
-			ret = -EINVAL;
-			dev_err(dev, "OF: voltage-range #%d is invalid\n", i);
-			goto err_ocr;
-		}
-		oms->pdata.ocr_mask |= mask;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(oms->gpios); i++) {
-		enum of_gpio_flags gpio_flags;
-
-		oms->gpios[i] = of_get_gpio_flags(np, i, &gpio_flags);
-		if (!gpio_is_valid(oms->gpios[i]))
-			continue;
-
-		ret = gpio_request(oms->gpios[i], dev->bus_id);
-		if (ret < 0) {
-			oms->gpios[i] = -EINVAL;
-			continue;
-		}
-
-		if (gpio_flags & OF_GPIO_ACTIVE_LOW)
-			oms->alow_gpios[i] = true;
-	}
-
-	if (gpio_is_valid(oms->gpios[CD_GPIO]))
-		oms->pdata.get_cd = of_mmc_spi_get_cd;
-	if (gpio_is_valid(oms->gpios[WP_GPIO]))
-		oms->pdata.get_ro = of_mmc_spi_get_ro;
-
-	/* We don't support interrupts yet, let's poll. */
-	oms->pdata.caps |= MMC_CAP_NEEDS_POLL;
-
-	dev->platform_data = &oms->pdata;
-	return dev->platform_data;
-err_ocr:
-	kfree(oms);
-	return NULL;
-}
-EXPORT_SYMBOL(mmc_spi_get_pdata);
-
-void mmc_spi_put_pdata(struct spi_device *spi)
-{
-	struct device *dev = &spi->dev;
-	struct device_node *np = dev_archdata_get_node(&dev->archdata);
-	struct of_mmc_spi *oms = to_of_mmc_spi(dev);
-	int i;
-
-	if (!dev->platform_data || !np)
-		return;
-
-	for (i = 0; i < ARRAY_SIZE(oms->gpios); i++) {
-		if (gpio_is_valid(oms->gpios[i]))
-			gpio_free(oms->gpios[i]);
-	}
-	kfree(oms);
-	dev->platform_data = NULL;
-}
-EXPORT_SYMBOL(mmc_spi_put_pdata);
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/omap_hsmmc.c linux-02.01.03.11-new/drivers/mmc/host/omap_hsmmc.c
--- linux-02.01.03.11-org/drivers/mmc/host/omap_hsmmc.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/omap_hsmmc.c	2010-01-18 20:49:56.000000000 +0800
@@ -121,6 +121,9 @@
 #define OMAP_HSMMC_WRITE(base, reg, val) \
 	__raw_writel((val), (base) + OMAP_HSMMC_##reg)
 
+enum {OFF = 0, ON};
+#define IDLE_TIMEOUT (jiffies_to_msecs(10))
+
 struct mmc_omap_host {
 	struct	device		*dev;
 	struct	mmc_host	*mmc;
@@ -148,120 +151,50 @@
 	int			initstr;
 	int			slot_id;
 	int			dbclk_enabled;
-	struct	omap_mmc_platform_data	*pdata;
-};
-
-struct omap_hsmmc_regs {
-	u32 hctl;
-	u32 capa;
-	u32 sysconfig;
-	u32 ise;
-	u32 ie;
-	u32 con;
-	u32 sysctl;
-};
-static struct omap_hsmmc_regs hsmmc_ctx[3];
-static int mmc_clk_counter [3];
-
-/*
- * restore the context
- */
-static void omap2_hsmmc_restore_ctx(struct mmc_omap_host *host)
-{
-	/* MMC : context restore */
-	OMAP_HSMMC_WRITE(host->base, HCTL, hsmmc_ctx[host->id].hctl);
-	OMAP_HSMMC_WRITE(host->base, CAPA, hsmmc_ctx[host->id].capa);
-	OMAP_HSMMC_WRITE(host->base, CON, hsmmc_ctx[host->id].con);
-	OMAP_HSMMC_WRITE(host->base, SYSCONFIG,
-					hsmmc_ctx[host->id].sysconfig);
-	OMAP_HSMMC_WRITE(host->base, ISE, hsmmc_ctx[host->id].ise);
-	OMAP_HSMMC_WRITE(host->base, IE, hsmmc_ctx[host->id].ie);
-	OMAP_HSMMC_WRITE(host->base, SYSCTL, hsmmc_ctx[host->id].sysctl);
-	OMAP_HSMMC_WRITE(host->base, HCTL, OMAP_HSMMC_READ(host->base,
-								HCTL) | SDBP);
-}
-
 
-/*
- * Save context
- */
-static void omap2_hsmmc_save_ctx(struct mmc_omap_host *host)
-{
-	/* MMC : context save */
-	hsmmc_ctx[host->id].hctl = OMAP_HSMMC_READ(host->base, HCTL);
-	hsmmc_ctx[host->id].capa = OMAP_HSMMC_READ(host->base, CAPA);
-	hsmmc_ctx[host->id].sysconfig = OMAP_HSMMC_READ(host->base,
-								SYSCONFIG);
-	hsmmc_ctx[host->id].ise = OMAP_HSMMC_READ(host->base, ISE);
-	hsmmc_ctx[host->id].ie = OMAP_HSMMC_READ(host->base, IE);
-	hsmmc_ctx[host->id].con = OMAP_HSMMC_READ(host->base, CON);
-	hsmmc_ctx[host->id].sysctl = OMAP_HSMMC_READ(host->base, SYSCTL);
-}
+	struct timer_list       idle_timer;
+	spinlock_t		clk_lock;     /* for changing enabled state */
+	unsigned int		fclk_enabled:1;
 
+	struct	omap_mmc_platform_data	*pdata;
+};
 
-/*
- *  enable clock to the card
- */
-static int mmc_clk_enable(struct mmc_omap_host *host)
+static int mmc_omap_fclk_state(struct mmc_omap_host *host, unsigned int state)
 {
+	unsigned long flags;
 	int ret = 0;
-	int hostid = host->id;
 
-	if (host) {
-		if (!mmc_clk_counter[hostid]) {
+	spin_lock_irqsave(&host->clk_lock, flags);
+	del_timer(&host->idle_timer);
+	if (host->fclk_enabled != state) {
+		if (state == ON) {
 			ret = clk_enable(host->fclk);
-			if (ret)
-				goto clk_en_err;
-
-			ret = clk_enable(host->iclk);
-			if (ret) {
-				clk_disable(host->fclk);
-				goto clk_en_err;
-			}
+			if (ret != 0)
+				goto err_out;
 
-			if(host->dbclk_enabled) {
-				if (clk_enable(host->dbclk) != 0){
-					clk_disable(host->fclk);
-					clk_disable(host->iclk);
-					dev_dbg(mmc_dev(host->mmc),
-						"Enabling debounce clk failed\n");
-				}
-			}
-			/*omap2_hsmmc_restore_ctx(host);*/
+			dev_dbg(mmc_dev(host->mmc), "mmc_fclk: enabled\n");
+		} else {
+			clk_disable(host->fclk);
+			dev_dbg(mmc_dev(host->mmc), "mmc_fclk: disabled\n");
 		}
-		mmc_clk_counter[hostid] = mmc_clk_counter[hostid]+1;
+		host->fclk_enabled = state;
 	}
-	return ret;
 
-clk_en_err:
-	dev_dbg(mmc_dev(host->mmc),
-		"Failed to enable MMC clocks during resume\n");
+err_out:
+	spin_unlock_irqrestore(&host->clk_lock, flags);
 	return ret;
 }
 
-
-/*
- * Disable clock to the card
- */
-
-static int mmc_clk_disable(struct mmc_omap_host *host)
+static void mmc_omap_idle_timer(unsigned long data)
 {
-	int hostid = host->id;
+	struct mmc_omap_host *host = (struct mmc_omap_host *) data;
 
-	if( mmc_clk_counter[hostid]) {
-	mmc_clk_counter[hostid] = mmc_clk_counter[hostid]-1;
-	}
-
-	if (!mmc_clk_counter[hostid]) {
-		/*omap2_hsmmc_save_ctx(host);*/
-		clk_disable(host->fclk);
-		clk_disable(host->iclk);
+	mmc_omap_fclk_state(host, OFF);
+}
 
-		if (host->dbclk_enabled) {
-			clk_disable(host->dbclk);
-		}
-	}
-	return 0;
+static void mmc_omap_fclk_lazy_disable(struct mmc_omap_host *host)
+{
+	mod_timer(&host->idle_timer, jiffies + IDLE_TIMEOUT);
 }
 
 /*
@@ -301,12 +234,9 @@
 static inline
 int mmc_omap_cover_is_closed(struct mmc_omap_host *host)
 {
-	int r = 1;
-
 	if (host->pdata->slots[host->slot_id].get_cover_state)
-		r = host->pdata->slots[host->slot_id].get_cover_state(host->dev,
-			host->slot_id);
-	return r;
+		return host->pdata->slots[host->slot_id].get_cover_state(host->dev, host->slot_id);
+	return 1;
 }
 
 static ssize_t
@@ -348,8 +278,6 @@
 		mmc_hostname(host->mmc), cmd->opcode, cmd->arg);
 	host->cmd = cmd;
 
-	mmc_clk_enable(host);
-
 	/*
 	 * Clear status bits and enable interrupts
 	 */
@@ -366,10 +294,9 @@
 
 	/*
 	 * Unlike OMAP1 controller, the cmdtype does not seem to be based on
-	 * ac, bc, adtc, bcr. Only commands ending an open ended transfer need
-	 * a val of 0x3, rest 0x0.
+	 * ac, bc, adtc, bcr. Only CMD12 needs a val of 0x3, rest 0x0.
 	 */
-	if (cmd == host->mrq->stop)
+	if (cmd->opcode == 12)
 		cmdtype = 0x3;
 
 	cmdreg = (cmd->opcode << 24) | (resptype << 16) | (cmdtype << 22);
@@ -408,10 +335,9 @@
 	else
 		data->bytes_xfered = 0;
 
-	mmc_clk_disable(host);
-
 	if (!data->stop) {
 		host->mrq = NULL;
+		mmc_omap_fclk_lazy_disable(host);
 		mmc_request_done(host->mmc, data->mrq);
 		return;
 	}
@@ -440,7 +366,7 @@
 	}
 	if (host->data == NULL || cmd->error) {
 		host->mrq = NULL;
-		mmc_clk_disable(host);
+		mmc_omap_fclk_lazy_disable(host);
 		mmc_request_done(host->mmc, cmd->mrq);
 	}
 }
@@ -476,20 +402,20 @@
 		"CEB", "CIE", "DTO", "DCRC", "DEB", "---", "ACE", "---",
 		"---", "---", "---", "CERR", "CERR", "BADA", "---", "---", "---"
 	};
-	char res[256];
-	char *buf = res;
-	int len, i;
+	int i;
 
-	len = sprintf(buf, "MMC IRQ 0x%x :", status);
-	buf += len;
+	dev_dbg(mmc_dev(host->mmc), "MMC IRQ 0x%x :", status);
 
 	for (i = 0; i < ARRAY_SIZE(mmc_omap_status_bits); i++)
-		if (status & (1 << i)) {
-			len = sprintf(buf, " %s", mmc_omap_status_bits[i]);
-			buf += len;
-		}
+		if (status & (1 << i))
+			/*
+			 * KERN_* facility is not used here because this should
+			 * print a single line.
+			 */
+			printk(" %s", mmc_omap_status_bits[i]);
+
+	printk("\n");
 
-	dev_dbg(mmc_dev(host->mmc), "%s\n", res);
 }
 #endif  /* CONFIG_MMC_DEBUG */
 
@@ -525,9 +451,7 @@
 						OMAP_HSMMC_READ(host->base,
 								SYSCTL) | SRC);
 					while (OMAP_HSMMC_READ(host->base,
-							SYSCTL) & SRC)
-						;
-
+								SYSCTL) & SRC) ;
 					host->cmd->error = -ETIMEDOUT;
 				} else {
 					host->cmd->error = -EILSEQ;
@@ -548,8 +472,7 @@
 					OMAP_HSMMC_READ(host->base,
 							SYSCTL) | SRD);
 				while (OMAP_HSMMC_READ(host->base,
-						SYSCTL) & SRD)
-					;
+							SYSCTL) & SRD) ;
 				end_trans = 1;
 			}
 		}
@@ -582,7 +505,9 @@
 	int ret;
 
 	/* Disable the clocks */
-	mmc_clk_disable(host);
+	mmc_omap_fclk_state(host, OFF);
+	clk_disable(host->iclk);
+	clk_disable(host->dbclk);
 
 	/* Turn the power off */
 	ret = mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);
@@ -594,7 +519,9 @@
 	if (ret != 0)
 		goto err;
 
-	mmc_clk_enable(host);
+	mmc_omap_fclk_state(host, ON);
+	clk_enable(host->iclk);
+	clk_enable(host->dbclk);
 
 	OMAP_HSMMC_WRITE(host->base, HCTL,
 		OMAP_HSMMC_READ(host->base, HCTL) & SDVSCLR);
@@ -602,15 +529,18 @@
 	/*
 	 * If a MMC dual voltage card is detected, the set_ios fn calls
 	 * this fn with VDD bit set for 1.8V. Upon card removal from the
-	 * slot, omap_mmc_set_ios sets the VDD back to 3V on MMC_POWER_OFF.
+	 * slot, mmc_omap_detect fn sets the VDD back to 3V.
 	 *
 	 * Only MMC1 supports 3.0V.  MMC2 will not function if SDVS30 is
 	 * set in HCTL.
 	 */
-	if (host->id == OMAP_MMC1_DEVID && (((1 << vdd) == MMC_VDD_32_33) ||
-				((1 << vdd) == MMC_VDD_33_34)))
-		reg_val |= SDVS30;
-	if ((1 << vdd) == MMC_VDD_165_195)
+	if (host->id == OMAP_MMC1_DEVID) {
+		if (((1 << vdd) == MMC_VDD_32_33) ||
+		    ((1 << vdd) == MMC_VDD_33_34))
+			reg_val |= SDVS30;
+		else if ((1 << vdd) == MMC_VDD_165_195)
+			reg_val |= SDVS18;
+	} else
 		reg_val |= SDVS18;
 
 	OMAP_HSMMC_WRITE(host->base, HCTL, reg_val);
@@ -629,26 +559,30 @@
  */
 static void mmc_omap_detect(struct work_struct *work)
 {
+	u16 vdd = 0;
 	struct mmc_omap_host *host = container_of(work, struct mmc_omap_host,
 						mmc_carddetect_work);
 
-	struct omap_mmc_slot_data *slot = &mmc_slot(host);
-
-	mmc_clk_enable(host);
-	host->carddetect = slot->card_detect(slot->card_detect_irq);
-
 	sysfs_notify(&host->mmc->class_dev.kobj, NULL, "cover_switch");
+	mmc_omap_fclk_state(host, ON);
 	if (host->carddetect) {
+		if (!(OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET)) {
+			/*
+			 * Set the VDD back to 3V when the card is removed
+			 * before the set_ios fn turns off the power.
+			 */
+			vdd = fls(host->mmc->ocr_avail) - 1;
+			if (omap_mmc_switch_opcond(host, vdd) != 0)
+				host->mmc->ios.vdd = vdd;
+		}
 		mmc_detect_change(host->mmc, (HZ * 200) / 1000);
 	} else {
 		OMAP_HSMMC_WRITE(host->base, SYSCTL,
 			OMAP_HSMMC_READ(host->base, SYSCTL) | SRD);
-		while (OMAP_HSMMC_READ(host->base, SYSCTL) & SRD)
-			;
-
+		while (OMAP_HSMMC_READ(host->base, SYSCTL) & SRD) ;
 		mmc_detect_change(host->mmc, (HZ * 50) / 1000);
 	}
-	mmc_clk_disable(host);
+	mmc_omap_fclk_lazy_disable(host);
 }
 
 /*
@@ -827,6 +761,7 @@
 {
 	int ret;
 	host->data = req->data;
+
 	if (req->data == NULL) {
 		host->datadir = OMAP_MMC_DATADIR_NONE;
 		OMAP_HSMMC_WRITE(host->base, BLK, 0);
@@ -858,15 +793,12 @@
 	struct mmc_omap_host *host = mmc_priv(mmc);
 
 	WARN_ON(host->mrq != NULL);
-	mmc_clk_enable(host);
 	host->mrq = req;
+	mmc_omap_fclk_state(host, ON);
 	mmc_omap_prepare_data(host, req);
-	mmc_clk_disable(host);
-
 	mmc_omap_start_command(host, req->cmd, req->data);
 }
 
-
 /* Routine to configure clock values. Exposed API to core */
 static void omap_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
@@ -874,31 +806,18 @@
 	u16 dsor = 0;
 	unsigned long regval;
 	unsigned long timeout;
-	
 
-	mmc_clk_enable(host);
+	mmc_omap_fclk_state(host, ON);
 
 	switch (ios->power_mode) {
 	case MMC_POWER_OFF:
 		mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);
-		/*
-		 * Reset bus voltage to 3V if it got set to 1.8V earlier.
-		 * REVISIT: If we are able to detect cards after unplugging
-		 * a 1.8V card, this code should not be needed.
-		 */
-		if (!(OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET)) {
-			int vdd = fls(host->mmc->ocr_avail) - 1;
-			if (omap_mmc_switch_opcond(host, vdd) != 0)
-				host->mmc->ios.vdd = vdd;
-		}
 		break;
 	case MMC_POWER_UP:
 		mmc_slot(host).set_power(host->dev, host->slot_id, 1, ios->vdd);
 		break;
 	}
 
-
-
 	switch (mmc->ios.bus_width) {
 	case MMC_BUS_WIDTH_4:
 		OMAP_HSMMC_WRITE(host->base, HCTL,
@@ -960,7 +879,8 @@
 	if (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)
 		OMAP_HSMMC_WRITE(host->base, CON,
 				OMAP_HSMMC_READ(host->base, CON) | OD);
-	mmc_clk_disable(host);
+
+	mmc_omap_fclk_lazy_disable(host);
 }
 
 static int omap_hsmmc_get_cd(struct mmc_host *mmc)
@@ -997,7 +917,7 @@
 	struct mmc_host *mmc;
 	struct mmc_omap_host *host = NULL;
 	struct resource *res;
-	int ret = 0, irq;
+	int ret = 0, irq, reg;
 	u32 hctl, capa;
 
 	if (pdata == NULL) {
@@ -1062,15 +982,34 @@
 		goto err1;
 	}
 
-	host->dbclk = clk_get(&pdev->dev, "gpt10_fck");
+	spin_lock_init(&host->clk_lock);
+	setup_timer(&host->idle_timer, mmc_omap_idle_timer,
+		    (unsigned long) host);
+
+	if (mmc_omap_fclk_state(host, ON) != 0) {
+		clk_put(host->iclk);
+		clk_put(host->fclk);
+		goto err1;
+	}
+	if (clk_enable(host->iclk) != 0) {
+		mmc_omap_fclk_state(host, OFF);
+		clk_put(host->iclk);
+		clk_put(host->fclk);
+		goto err1;
+	}
+
+	host->dbclk = clk_get(&pdev->dev, "mmchsdb_fck");
 	/*
 	 * MMC can still work without debounce clock.
 	 */
 	if (IS_ERR(host->dbclk))
-		dev_warn(mmc_dev(host->mmc), "Failed to get debounce clock\n");
-	
-	host->dbclk_enabled = 1;
-	mmc_clk_enable(host);
+		dev_dbg(mmc_dev(host->mmc), "Failed to get debounce clock\n");
+	else
+		if (clk_enable(host->dbclk) != 0)
+			dev_dbg(mmc_dev(host->mmc), "Enabling debounce"
+							" clk failed\n");
+		else
+			host->dbclk_enabled = 1;
 
 #ifdef CONFIG_MMC_BLOCK_BOUNCE
 	mmc->max_phys_segs = 1;
@@ -1129,9 +1068,9 @@
 	/* Request IRQ for card detect */
 	if ((mmc_slot(host).card_detect_irq) && (mmc_slot(host).card_detect)) {
 		ret = request_irq(mmc_slot(host).card_detect_irq,
-				omap_mmc_cd_handler,
-				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING
-					| IRQF_DISABLED,
+				  omap_mmc_cd_handler,
+				  IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING
+					  | IRQF_DISABLED,
 				  mmc_hostname(mmc), host);
 		if (ret) {
 			dev_dbg(mmc_dev(host->mmc),
@@ -1152,13 +1091,11 @@
 	}
 	if (mmc_slot(host).card_detect_irq && mmc_slot(host).card_detect &&
 			host->pdata->slots[host->slot_id].get_cover_state) {
-		ret = device_create_file(&mmc->class_dev,
-					&dev_attr_cover_switch);
+		ret = device_create_file(&mmc->class_dev, &dev_attr_cover_switch);
 		if (ret < 0)
 			goto err_cover_switch;
 	}
-
-	mmc_clk_disable(host);
+	mmc_omap_fclk_lazy_disable(host);
 
 	return 0;
 
@@ -1171,10 +1108,14 @@
 err_irq_cd_init:
 	free_irq(host->irq, host);
 err_irq:
-	mmc_clk_disable(host);
+	mmc_omap_fclk_state(host, OFF);
+	clk_disable(host->iclk);
 	clk_put(host->fclk);
 	clk_put(host->iclk);
-	clk_put(host->dbclk);
+	if (host->dbclk_enabled) {
+		clk_disable(host->dbclk);
+		clk_put(host->dbclk);
+	}
 
 err1:
 	iounmap(host->base);
@@ -1190,7 +1131,26 @@
 {
 	struct mmc_omap_host *host = platform_get_drvdata(pdev);
 	struct resource *res;
+	u16 vdd = 0;
+
+	if (host) {
+		mmc_omap_fclk_state(host, ON);
+		if (!(OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET)) {
+			/*
+			 * Set the vdd back to 3V,
+			 * applicable for dual volt support.
+			 */
+			vdd = fls(host->mmc->ocr_avail) - 1;
+			if (omap_mmc_switch_opcond(host, vdd) != 0)
+				host->mmc->ios.vdd = vdd;
+		}
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res)
+		release_mem_region(res->start, res->end - res->start + 1);
 
+	platform_set_drvdata(pdev, NULL);
 	if (host) {
 		mmc_remove_host(host->mmc);
 		if (host->pdata->cleanup)
@@ -1200,20 +1160,19 @@
 			free_irq(mmc_slot(host).card_detect_irq, host);
 		flush_scheduled_work();
 
-		mmc_clk_disable(host);
+		mmc_omap_fclk_state(host, OFF);
+		clk_disable(host->iclk);
 		clk_put(host->fclk);
 		clk_put(host->iclk);
-		clk_put(host->dbclk);
+		if (host->dbclk_enabled) {
+			clk_disable(host->dbclk);
+			clk_put(host->dbclk);
+		}
 
 		mmc_free_host(host->mmc);
 		iounmap(host->base);
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (res)
-		release_mem_region(res->start, res->end - res->start + 1);
-	platform_set_drvdata(pdev, NULL);
-
 	return 0;
 }
 
@@ -1231,32 +1190,23 @@
 		if (ret == 0) {
 			host->suspended = 1;
 
-			mmc_clk_enable(host);
-
+			mmc_omap_fclk_state(host, ON);
 			OMAP_HSMMC_WRITE(host->base, ISE, 0);
 			OMAP_HSMMC_WRITE(host->base, IE, 0);
 
 			if (host->pdata->suspend) {
-				ret = host->pdata->suspend(&pdev->dev,
-								host->slot_id);
+				ret = host->pdata->suspend(&pdev->dev, host->slot_id);
 				if (ret)
 					dev_dbg(mmc_dev(host->mmc),
 						"Unable to handle MMC board"
 						" level suspend\n");
 			}
 
-			if (!(OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET)) {
-				OMAP_HSMMC_WRITE(host->base, HCTL,
-					OMAP_HSMMC_READ(host->base, HCTL)
-					& SDVSCLR);
-				OMAP_HSMMC_WRITE(host->base, HCTL,
-					OMAP_HSMMC_READ(host->base, HCTL)
-					| SDVS30);
-				OMAP_HSMMC_WRITE(host->base, HCTL,
-					OMAP_HSMMC_READ(host->base, HCTL)
-					| SDBP);
-			}
-			mmc_clk_disable(host);
+			OMAP_HSMMC_WRITE(host->base, HCTL,
+					 OMAP_HSMMC_READ(host->base, HCTL) & ~SDBP);
+			mmc_omap_fclk_state(host, OFF);
+			clk_disable(host->iclk);
+			clk_disable(host->dbclk);
 		}
 
 	}
@@ -1273,7 +1223,27 @@
 		return 0;
 
 	if (host) {
-		mmc_clk_enable(host);
+		int i;
+		if (mmc_omap_fclk_state(host, ON) != 0)
+			goto clk_en_err;
+
+		ret = clk_enable(host->iclk);
+		if (ret) {
+			mmc_omap_fclk_state(host, OFF);
+			clk_put(host->fclk);
+			goto clk_en_err;
+		}
+
+		if (clk_enable(host->dbclk) != 0)
+			dev_dbg(mmc_dev(host->mmc),
+					"Enabling debounce clk failed\n");
+
+		OMAP_HSMMC_WRITE(host->base, HCTL,
+				 OMAP_HSMMC_READ(host->base, HCTL) | SDBP);
+
+		for (i = 0; i < 100; i++)
+			if (OMAP_HSMMC_READ(host->base, HCTL) & SDBP)
+				break;
 
 		if (host->pdata->resume) {
 			ret = host->pdata->resume(&pdev->dev, host->slot_id);
@@ -1286,9 +1256,16 @@
 		ret = mmc_resume_host(host->mmc);
 		if (ret == 0)
 			host->suspended = 0;
+
+		mmc_omap_fclk_lazy_disable(host);
 	}
 
 	return ret;
+
+clk_en_err:
+	dev_dbg(mmc_dev(host->mmc),
+		"Failed to enable MMC clocks during resume\n");
+	return ret;
 }
 
 #else
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/pxamci.c linux-02.01.03.11-new/drivers/mmc/host/pxamci.c
--- linux-02.01.03.11-org/drivers/mmc/host/pxamci.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/pxamci.c	2010-01-18 20:34:31.000000000 +0800
@@ -26,12 +26,11 @@
 #include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/mmc/host.h>
-#include <linux/io.h>
 
+#include <asm/dma.h>
+#include <asm/io.h>
 #include <asm/sizes.h>
 
-#include <mach/dma.h>
-#include <mach/hardware.h>
 #include <mach/pxa-regs.h>
 #include <mach/mmc.h>
 
@@ -283,7 +282,7 @@
 		return 0;
 
 	DCSR(host->dma) = 0;
-	dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,
+	dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->dma_len,
 		     host->dma_dir);
 
 	if (stat & STAT_READ_TIME_OUT)
@@ -534,7 +533,7 @@
 	host->pdata = pdev->dev.platform_data;
 	host->clkrt = CLKRT_OFF;
 
-	host->clk = clk_get(&pdev->dev, NULL);
+	host->clk = clk_get(&pdev->dev, "MMCCLK");
 	if (IS_ERR(host->clk)) {
 		ret = PTR_ERR(host->clk);
 		host->clk = NULL;
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/ricoh_mmc.c linux-02.01.03.11-new/drivers/mmc/host/ricoh_mmc.c
--- linux-02.01.03.11-org/drivers/mmc/host/ricoh_mmc.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/ricoh_mmc.c	2010-01-18 20:34:31.000000000 +0800
@@ -11,10 +11,9 @@
 
 /*
  * This is a conceptually ridiculous driver, but it is required by the way
- * the Ricoh multi-function chips (R5CXXX) work. These chips implement
- * the four main memory card controllers (SD, MMC, MS, xD) and one or both
- * of cardbus or firewire. It happens that they implement SD and MMC
- * support as separate controllers (and PCI functions). The linux SDHCI
+ * the Ricoh multi-function R5C832 works. This chip implements firewire
+ * and four different memory card controllers. Two of those controllers are
+ * an SDHCI controller and a proprietary MMC controller. The linux SDHCI
  * driver supports MMC cards but the chip detects MMC cards in hardware
  * and directs them to the MMC controller - so the SDHCI driver never sees
  * them. To get around this, we must disable the useless MMC controller.
@@ -22,10 +21,8 @@
  * a detection event occurs immediately, even if the MMC card is already
  * in the reader.
  *
- * It seems to be the case that the relevant PCI registers to deactivate the
- * MMC controller live on PCI function 0, which might be the cardbus controller
- * or the firewire controller, depending on the particular chip in question. As
- * such, it makes what this driver has to do unavoidably ugly. Such is life.
+ * The relevant registers live on the firewire function, so this is unavoidably
+ * ugly. Such is life.
  */
 
 #include <linux/pci.h>
@@ -146,7 +143,6 @@
 		pci_get_device(PCI_VENDOR_ID_RICOH,
 			PCI_DEVICE_ID_RICOH_RL5C476, fw_dev))) {
 		if (PCI_SLOT(pdev->devfn) == PCI_SLOT(fw_dev->devfn) &&
-		    PCI_FUNC(fw_dev->devfn) == 0 &&
 		    pdev->bus == fw_dev->bus) {
 			if (ricoh_mmc_disable(fw_dev) != 0)
 				return -ENODEV;
@@ -164,7 +160,6 @@
 	    (fw_dev = pci_get_device(PCI_VENDOR_ID_RICOH,
 					PCI_DEVICE_ID_RICOH_R5C832, fw_dev))) {
 		if (PCI_SLOT(pdev->devfn) == PCI_SLOT(fw_dev->devfn) &&
-		    PCI_FUNC(fw_dev->devfn) == 0 &&
 		    pdev->bus == fw_dev->bus) {
 			if (ricoh_mmc_disable(fw_dev) != 0)
 				return -ENODEV;
@@ -177,7 +172,7 @@
 
 	if (!ctrlfound) {
 		printk(KERN_WARNING DRIVER_NAME
-		       ": Main Ricoh function not found. Cannot disable controller.\n");
+		       ": Main firewire function not found. Cannot disable controller.\n");
 		return -ENODEV;
 	}
 
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/s3cmci.c linux-02.01.03.11-new/drivers/mmc/host/s3cmci.c
--- linux-02.01.03.11-org/drivers/mmc/host/s3cmci.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/s3cmci.c	2010-01-18 20:34:31.000000000 +0800
@@ -20,12 +20,12 @@
 #include <linux/irq.h>
 #include <linux/io.h>
 
-#include <mach/dma.h>
+#include <asm/dma.h>
 
 #include <mach/regs-sdi.h>
 #include <mach/regs-gpio.h>
 
-#include <plat/mci.h>
+#include <asm/plat-s3c24xx/mci.h>
 
 #include "s3cmci.h"
 
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/sdhci.c linux-02.01.03.11-new/drivers/mmc/host/sdhci.c
--- linux-02.01.03.11-org/drivers/mmc/host/sdhci.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/sdhci.c	2010-01-18 20:34:31.000000000 +0800
@@ -30,11 +30,6 @@
 #define DBG(f, x...) \
 	pr_debug(DRIVER_NAME " [%s()]: " f, __func__,## x)
 
-#if defined(CONFIG_LEDS_CLASS) || (defined(CONFIG_LEDS_CLASS_MODULE) && \
-	defined(CONFIG_MMC_SDHCI_MODULE))
-#define SDHCI_USE_LEDS_CLASS
-#endif
-
 static unsigned int debug_quirks = 0;
 
 static void sdhci_prepare_data(struct sdhci_host *, struct mmc_data *);
@@ -154,7 +149,7 @@
 	writeb(ctrl, host->ioaddr + SDHCI_HOST_CONTROL);
 }
 
-#ifdef SDHCI_USE_LEDS_CLASS
+#ifdef CONFIG_LEDS_CLASS
 static void sdhci_led_control(struct led_classdev *led,
 	enum led_brightness brightness)
 {
@@ -999,7 +994,7 @@
 
 	WARN_ON(host->mrq != NULL);
 
-#ifndef SDHCI_USE_LEDS_CLASS
+#ifndef CONFIG_LEDS_CLASS
 	sdhci_activate_led(host);
 #endif
 
@@ -1206,7 +1201,7 @@
 	host->cmd = NULL;
 	host->data = NULL;
 
-#ifndef SDHCI_USE_LEDS_CLASS
+#ifndef CONFIG_LEDS_CLASS
 	sdhci_deactivate_led(host);
 #endif
 
@@ -1722,7 +1717,7 @@
 	sdhci_dumpregs(host);
 #endif
 
-#ifdef SDHCI_USE_LEDS_CLASS
+#ifdef CONFIG_LEDS_CLASS
 	host->led.name = mmc_hostname(mmc);
 	host->led.brightness = LED_OFF;
 	host->led.default_trigger = mmc_hostname(mmc);
@@ -1744,7 +1739,7 @@
 
 	return 0;
 
-#ifdef SDHCI_USE_LEDS_CLASS
+#ifdef CONFIG_LEDS_CLASS
 reset:
 	sdhci_reset(host, SDHCI_RESET_ALL);
 	free_irq(host->irq, host);
@@ -1780,7 +1775,7 @@
 
 	mmc_remove_host(host->mmc);
 
-#ifdef SDHCI_USE_LEDS_CLASS
+#ifdef CONFIG_LEDS_CLASS
 	led_classdev_unregister(&host->led);
 #endif
 
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/sdhci.h linux-02.01.03.11-new/drivers/mmc/host/sdhci.h
--- linux-02.01.03.11-org/drivers/mmc/host/sdhci.h	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/sdhci.h	2010-01-18 20:34:31.000000000 +0800
@@ -220,7 +220,7 @@
 	struct mmc_host		*mmc;		/* MMC structure */
 	u64			dma_mask;	/* custom DMA mask */
 
-#if defined(CONFIG_LEDS_CLASS) || defined(CONFIG_LEDS_CLASS_MODULE)
+#ifdef CONFIG_LEDS_CLASS
 	struct led_classdev	led;		/* LED control */
 #endif
 
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/sdhci-pci.c linux-02.01.03.11-new/drivers/mmc/host/sdhci-pci.c
--- linux-02.01.03.11-org/drivers/mmc/host/sdhci-pci.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/sdhci-pci.c	2010-01-18 20:34:31.000000000 +0800
@@ -545,7 +545,7 @@
 	}
 
 	addr = pci_resource_start(pdev, bar);
-	host->ioaddr = pci_ioremap_bar(pdev, bar);
+	host->ioaddr = ioremap_nocache(addr, pci_resource_len(pdev, bar));
 	if (!host->ioaddr) {
 		dev_err(&pdev->dev, "failed to remap registers\n");
 		goto release;
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/sdricoh_cs.c linux-02.01.03.11-new/drivers/mmc/host/sdricoh_cs.c
--- linux-02.01.03.11-org/drivers/mmc/host/sdricoh_cs.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/sdricoh_cs.c	2010-01-18 20:34:30.000000000 +0800
@@ -82,8 +82,6 @@
 	/* vendor and device strings followed by their crc32 hashes */
 	PCMCIA_DEVICE_PROD_ID12("RICOH", "Bay1Controller", 0xd9f522ed,
 				0xc3901202),
-	PCMCIA_DEVICE_PROD_ID12("RICOH", "Bay Controller", 0xd9f522ed,
-				0xace80909),
 	PCMCIA_DEVICE_NULL,
 };
 
@@ -465,7 +463,7 @@
 
 err:
 	if (iobase)
-		pci_iounmap(pci_dev, iobase);
+		iounmap(iobase);
 	if (mmc)
 		mmc_free_host(mmc);
 
diff -ruN linux-02.01.03.11-org/drivers/mmc/host/tmio_mmc.c linux-02.01.03.11-new/drivers/mmc/host/tmio_mmc.c
--- linux-02.01.03.11-org/drivers/mmc/host/tmio_mmc.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/mmc/host/tmio_mmc.c	2010-01-18 20:34:31.000000000 +0800
@@ -224,7 +224,7 @@
 {
 	void __iomem *ctl = host->ctl;
 	struct mmc_data *data = host->data;
-	struct mmc_command *stop;
+	struct mmc_command *stop = data->stop;
 
 	host->data = NULL;
 
@@ -232,7 +232,6 @@
 		pr_debug("Spurious data end IRQ\n");
 		return;
 	}
-	stop = data->stop;
 
 	/* FIXME - return correct transfer count on errors */
 	if (!data->error)
diff -ruN linux-02.01.03.11-org/drivers/net/dm9000.c linux-02.01.03.11-new/drivers/net/dm9000.c
--- linux-02.01.03.11-org/drivers/net/dm9000.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/net/dm9000.c	2010-02-08 18:59:29.000000000 +0800
@@ -53,6 +53,7 @@
 static int watchdog = 5000;
 module_param(watchdog, int, 0400);
 MODULE_PARM_DESC(watchdog, "transmit timeout in milliseconds");
+static unsigned char mac_addr[6] = {0x00,0x11,0x22,0x33,0x44,0x55};//embest
 
 /* DM9000 register address locking.
  *
@@ -1170,6 +1171,22 @@
 
 #define res_size(_r) (((_r)->end - (_r)->start) + 1)
 
+static const struct net_device_ops dm9000_netdev_ops = {
+         .ndo_open = dm9000_open,
+         .ndo_stop = dm9000_stop,
+         .ndo_start_xmit = dm9000_start_xmit,
+         .ndo_tx_timeout = dm9000_timeout,
+         .ndo_set_multicast_list = dm9000_hash_table,
+         .ndo_do_ioctl = dm9000_ioctl,
+         .ndo_change_mtu = eth_change_mtu,
+         .ndo_validate_addr = eth_validate_addr,
+         .ndo_set_mac_address = eth_mac_addr,
+    #ifdef CONFIG_NET_POLL_CONTROLLER
+         .ndo_poll_controller = dm9000_poll_controller,
+    #endif
+};
+
+
 /*
  * Search DM9000 board, allocate space and register it
  */
@@ -1195,7 +1212,7 @@
 	SET_NETDEV_DEV(ndev, &pdev->dev);
 
 	dev_dbg(&pdev->dev, "dm9000_probe()\n");
-
+	 ndev->netdev_ops = &dm9000_netdev_ops;
 	/* setup board info structure */
 	db = netdev_priv(ndev);
 	memset(db, 0, sizeof(*db));
@@ -1375,7 +1392,8 @@
 		
 		mac_src = "chip";
 		for (i = 0; i < 6; i++)
-			ndev->dev_addr[i] = ior(db, i+DM9000_PAR);
+		//	ndev->dev_addr[i] = ior(db, i+DM9000_PAR);
+			ndev->dev_addr[i] = mac_addr[i];//embest
 	}
 
 	if (!is_valid_ether_addr(ndev->dev_addr))
diff -ruN linux-02.01.03.11-org/drivers/usb/host/ehci-omap.c linux-02.01.03.11-new/drivers/usb/host/ehci-omap.c
--- linux-02.01.03.11-org/drivers/usb/host/ehci-omap.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/usb/host/ehci-omap.c	2010-01-20 08:37:25.000000000 +0800
@@ -39,12 +39,17 @@
  * Mistral/Multimedia daughter card connected to OMAP3EVM
  * The board has only Port2 connected to SMSC USB83320 in 12-pin ULPI mode
  */
+#if 0
 #ifdef CONFIG_MACH_OMAP3EVM
 u8     EXT_PHY_RESET_GPIO_PORT2;
 #elif CONFIG_OMAP3430SDP_750_2083_001
 #define	EXT_PHY_RESET_GPIO_PORT1	(57)
 #define	EXT_PHY_RESET_GPIO_PORT2	(61)
 #endif
+#endif
+
+#define EXT_PHY_RESET_GPIO_PORT1       	(24)
+#define EXT_PHY_RESET_GPIO_PORT2        (61)
 
 #if defined(CONFIG_OMAP_EHCI_PHY_MODE_PORT1)	|| \
 	defined(CONFIG_OMAP_EHCI_PHY_MODE_PORT2)
@@ -240,7 +245,7 @@
 	clk_enable(ehci_clocks->usbhost1_48m_fck_clk);
 
 	/* get phy reset gpio number */
-	EXT_PHY_RESET_GPIO_PORT2 = omap3_ehci_phy_reset_gpio;
+//	EXT_PHY_RESET_GPIO_PORT2 = omap3_ehci_phy_reset_gpio;
 
 #ifdef EXTERNAL_PHY_RESET
 	/* Refer: ISSUE1 */
diff -ruN linux-02.01.03.11-org/drivers/usb/musb/omap2430.c linux-02.01.03.11-new/drivers/usb/musb/omap2430.c
--- linux-02.01.03.11-org/drivers/usb/musb/omap2430.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/usb/musb/omap2430.c	2010-01-18 21:13:51.000000000 +0800
@@ -256,11 +256,11 @@
 	omap_writel(l, OTG_INTERFSEL);
 
 	/* Program PHY to use external Vbus supply on new OMAP3EVM */
-	if (get_omap3evm_board_rev() >= OMAP3EVM_BOARD_GEN_2) {
-		val = musb_readb(musb->mregs, MUSB_ULPI_BUSCONTROL);
-		val |= ULPI_USE_EXTVBUS;
-		musb_writeb(musb->mregs, MUSB_ULPI_BUSCONTROL, val);
-	}
+//	if (get_omap3evm_board_rev() >= OMAP3EVM_BOARD_GEN_2) {
+//		val = musb_readb(musb->mregs, MUSB_ULPI_BUSCONTROL);
+//		val |= ULPI_USE_EXTVBUS;
+//		musb_writeb(musb->mregs, MUSB_ULPI_BUSCONTROL, val);
+//	}
 
 	pr_debug("HS USB OTG: revision 0x%x, sysconfig 0x%02x, "
 			"sysstatus 0x%x, intrfsel 0x%x, simenable  0x%x\n",
diff -ruN linux-02.01.03.11-org/drivers/video/omap/lcd_omap3devkit8000.c linux-02.01.03.11-new/drivers/video/omap/lcd_omap3devkit8000.c
--- linux-02.01.03.11-org/drivers/video/omap/lcd_omap3devkit8000.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-02.01.03.11-new/drivers/video/omap/lcd_omap3devkit8000.c	2010-01-18 19:26:54.000000000 +0800
@@ -0,0 +1,256 @@
+/*
+ * LCD panel support for the TI OMAP3 Beagle board
+ *
+ * Author: Koen Kooi <koen@openembedded.org>
+ *
+ * Derived from drivers/video/omap/lcd-omap3evm.c
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/i2c/twl4030.h>
+
+#include <mach/mux.h>
+#include <mach/omapfb.h>
+#include <asm/mach-types.h>
+
+#define DVI
+//#undef DVI
+
+#define LCD_PANEL_ENABLE_GPIO       170
+/*
+#define LCD_PANEL_ENABLE_GPIO       173
+#define LCD_PANEL_LR                2
+#define LCD_PANEL_UD                3
+#define LCD_PANEL_INI               152
+#define LCD_PANEL_QVGA              154
+#define LCD_PANEL_RESB              155
+*/
+
+#ifdef DVI
+//#define LCD_XRES		1024	
+//#define LCD_YRES 		768
+//#define LCD_PIXCLOCK		64000 /* in kHz */
+
+#define LCD_XRES		1280	
+#define LCD_YRES 		720
+#define LCD_PIXCLOCK		74250 /* in kHz */
+#else
+//#define LCD_XRES		480	
+//#define LCD_YRES 		640
+//#define LCD_PIXCLOCK		26000 /* in kHz */
+
+
+#define LCD_XRES		480	
+#define LCD_YRES 		272
+#define LCD_PIXCLOCK		10000 /* in kHz */
+#endif
+
+#define TWL_LED_LEDEN           0x00
+#define TWL_PWMA_PWMAON         0x00
+#define TWL_PWMA_PWMAOFF        0x01
+
+static int omap3_devkit8000_panel_init(struct lcd_panel *panel,
+				struct omapfb_device *fbdev)
+{
+	printk("%s was invoked\n", __FUNCTION__);
+#if 0	
+	gpio_request(LCD_PANEL_ENABLE_GPIO, "LCD enable");
+#else
+	twl4030_i2c_write_u8(TWL4030_MODULE_GPIO, 0x80, REG_GPIODATADIR1);//set to output
+	twl4030_i2c_write_u8(TWL4030_MODULE_LED, 0x00, TWL_LED_LEDEN);
+#endif
+/*
+ 	gpio_request(LCD_PANEL_LR, "LCD lr");
+	gpio_request(LCD_PANEL_UD, "LCD ud");
+	gpio_request(LCD_PANEL_INI, "LCD ini");
+	gpio_request(LCD_PANEL_RESB, "LCD resb");
+	gpio_request(LCD_PANEL_QVGA, "LCD qvga");
+
+	gpio_direction_output(LCD_PANEL_RESB, 1);
+	gpio_direction_output(LCD_PANEL_INI, 1);
+	gpio_direction_output(LCD_PANEL_QVGA, 0);
+	gpio_direction_output(LCD_PANEL_LR, 1);
+	gpio_direction_output(LCD_PANEL_UD, 1);
+
+	twl4030_i2c_write_u8(TWL4030_MODULE_LED, 0x11, TWL_LED_LEDEN);
+	twl4030_i2c_write_u8(TWL4030_MODULE_PWMA, 0x01, TWL_PWMA_PWMAON);
+	twl4030_i2c_write_u8(TWL4030_MODULE_PWMA, 0x02, TWL_PWMA_PWMAOFF);
+	*/
+	return 0;
+}
+
+static void omap3_devkit8000_panel_cleanup(struct lcd_panel *panel)
+{
+}
+
+static int omap3_devkit8000_panel_enable(struct lcd_panel *panel)
+{
+#if 0
+	gpio_set_value(LCD_PANEL_ENABLE_GPIO, 1);
+#else
+	twl4030_i2c_write_u8(TWL4030_MODULE_GPIO, 0x80, REG_GPIODATAOUT1);//output '1'
+	twl4030_i2c_write_u8(TWL4030_MODULE_LED, 0x00, TWL_LED_LEDEN);
+#endif
+	return 0;
+}
+
+static void omap3_devkit8000_panel_disable(struct lcd_panel *panel)
+{
+#if 0
+	gpio_set_value(LCD_PANEL_ENABLE_GPIO, 0);
+#else
+	twl4030_i2c_write_u8(TWL4030_MODULE_GPIO, 0x00, REG_GPIODATAOUT1);
+	twl4030_i2c_write_u8(TWL4030_MODULE_LED, 0x33, TWL_LED_LEDEN);
+#endif
+}
+
+static unsigned long omap3_devkit8000_panel_get_caps(struct lcd_panel *panel)
+{
+	return 0;
+}
+
+struct lcd_panel omap3_devkit8000_panel = {
+	.name		= "omap3_devkit8000",
+#ifndef DVI
+	.config		= OMAP_LCDC_PANEL_TFT | OMAP_LCDC_INV_VSYNC | OMAP_LCDC_INV_HSYNC,
+#else
+	.config		= OMAP_LCDC_PANEL_TFT, /*| OMAP_LCDC_HSVS_OPPOSITE*/
+	//| OMAP_LCDC_HSVS_RISING_EDGE | OMAP_LCDC_HSVS_OPPOSITE,
+#endif
+
+#ifndef DVI
+	.bpp		= 16,
+	.data_lines	= 24,
+	.x_res		= LCD_XRES,
+	.y_res		= LCD_YRES,
+	.hsw		= 41,		/* hsync_len (4) - 1 */
+	.hfp		= 2,		/* right_margin (4) - 1 */
+	.hbp		= 2,		/* left_margin (40) - 1 */
+	.vsw		= 10,		/* vsync_len (2) - 1 */
+	.vfp		= 2,		/* lower_margin */
+	.vbp		= 2,		/* upper_margin (8) - 1 */
+#else
+
+	
+#if 0	/********  mistral config ***************/	
+	.bpp		= 16,
+	.data_lines	= 18,
+	.x_res		= LCD_XRES,
+	.y_res		= LCD_YRES,
+	.hsw		= 4,		/* hsync_len (4) - 1 */
+	.hfp		= 75,		/* right_margin (4) - 1 */
+	.hbp		= 65,		/* left_margin (40) - 1 */
+	.vsw		= 2,		/* vsync_len (2) - 1 */
+	.vfp		= 2,		/* lower_margin */
+	.vbp		= 2,		/* upper_margin (8) - 1 */
+#endif
+
+	/***********  devkit9000  config *******************/
+	.bpp		= 16,
+	.data_lines	= 24,
+	.x_res		= LCD_XRES,
+	.y_res		= LCD_YRES,
+	.hsw		= 40,		/* hsync_len (4) - 1 */
+	.hfp		= 110,		/* right_margin (4) - 1 */
+	.hbp		= 220,		/* left_margin (40) - 1 */
+	.vsw		= 5,		/* vsync_len (2) - 1 */
+	.vfp		= 20,		/* lower_margin */
+	.vbp		= 5,		/* upper_margin (8) - 1 */
+
+#if 0	/***********  devkit9000  config *******************/
+	.bpp		= 16,
+	.data_lines	= 24,
+	.x_res		= LCD_XRES,
+	.y_res		= LCD_YRES,
+	.hsw		= 0x31,		/* hsync_len (4) - 1 */
+	.hfp		= 0x3f,		/* right_margin (4) - 1 */
+	.hbp		= 0xff,		/* left_margin (40) - 1 */
+	.vsw		= 0x4,		/* vsync_len (2) - 1 */
+	.vfp		= 0x5,		/* lower_margin */
+	.vbp		= 0x14,		/* upper_margin (8) - 1 */
+#endif
+
+#if 0	/***********  devkit9000  config *******************/
+	.bpp		= 24,
+	.data_lines	= 24,
+	.x_res		= LCD_XRES,
+	.y_res		= LCD_YRES,
+	.hsw		= 0x1,		/* hsync_len (4) - 1 */
+	.hfp		= 0x20,		/* right_margin (4) - 1 */
+	.hbp		= 0x20,		/* left_margin (40) - 1 */
+	.vsw		= 0x1,		/* vsync_len (2) - 1 */
+	.vfp		= 0x20,		/* lower_margin */
+	.vbp		= 0x20,		/* upper_margin (8) - 1 */
+#endif
+#endif
+
+	.pixel_clock	= LCD_PIXCLOCK,
+	.init		= omap3_devkit8000_panel_init,
+	.cleanup	= omap3_devkit8000_panel_cleanup,
+	.enable		= omap3_devkit8000_panel_enable,
+	.disable	= omap3_devkit8000_panel_disable,
+	.get_caps	= omap3_devkit8000_panel_get_caps,
+};
+
+
+static int omap3_devkit8000_panel_probe(struct platform_device *pdev)
+{
+	omapfb_register_panel(&omap3_devkit8000_panel);
+	return 0;
+}
+
+static int omap3_devkit8000_panel_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int omap3_devkit8000_panel_suspend(struct platform_device *pdev,
+				   pm_message_t mesg)
+{
+	return 0;
+}
+
+static int omap3_devkit8000_panel_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+struct platform_driver omap3_devkit8000_panel_driver = {
+	.probe		= omap3_devkit8000_panel_probe,
+	.remove		= omap3_devkit8000_panel_remove,
+	.suspend	= omap3_devkit8000_panel_suspend,
+	.resume		= omap3_devkit8000_panel_resume,
+	.driver		= {
+		.name	= "omap3_devkit8000_lcd",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init omap3_devkit8000_panel_drv_init(void)
+{
+	return platform_driver_register(&omap3_devkit8000_panel_driver);
+}
+
+static void __exit omap3_devkit8000_panel_drv_exit(void)
+{
+	platform_driver_unregister(&omap3_devkit8000_panel_driver);
+}
+
+module_init(omap3_devkit8000_panel_drv_init);
+module_exit(omap3_devkit8000_panel_drv_exit);
diff -ruN linux-02.01.03.11-org/drivers/video/omap/Makefile linux-02.01.03.11-new/drivers/video/omap/Makefile
--- linux-02.01.03.11-org/drivers/video/omap/Makefile	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/video/omap/Makefile	2010-02-08 18:58:26.000000000 +0800
@@ -38,3 +38,5 @@
 
 omapfb-objs := $(objs-yy)
 
+objs-y$(CONFIG_MACH_OMAP3_DEVKIT8000) += lcd_omap3devkit8000.o
+
diff -ruN linux-02.01.03.11-org/drivers/video/omap2/omapfb-main.c linux-02.01.03.11-new/drivers/video/omap2/omapfb-main.c
--- linux-02.01.03.11-org/drivers/video/omap2/omapfb-main.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/drivers/video/omap2/omapfb-main.c	2010-02-08 19:00:51.000000000 +0800
@@ -35,10 +35,26 @@
 
 #define MODULE_NAME     "omapfb"
 
-static char *def_mode;
+struct video_mode {
+        const char      *name;
+        int             x_res, y_res;
+        int             pixel_clock;    /* In kHz */
+        int             hsw;            /* Horizontal synchronization
+                                           pulse width */
+        int             hfp;            /* Horizontal front porch */
+        int             hbp;            /* Horizontal back porch */
+        int             vsw;            /* Vertical synchronization
+                                           pulse width */
+        int             vfp;            /* Vertical front porch */
+        int             vbp;            /* Vertical back porch */
+};
+
+//static char *def_mode;
+static char	def_mode[16];
 static char *def_vram;
 static int def_rotate_type = -1;
 static int def_rotate = -1;
+static struct video_mode        video_mode;
 
 #define VRFB_WIDTH 	(2048)
 #define FB_SIZE 	(1280 * 720 * 4 * 2)
@@ -56,6 +72,213 @@
 module_param_named(debug, omapfb_debug, bool, 0644);
 #endif
 
+static struct video_mode video_modes[] __initdata = {
+	{
+		/* 640 x 480 @ 60 Hz  Reduced blanking VESA CVT 0.31M3-R */
+		.name		= "640x480@60",
+		.x_res		= 640,
+		.y_res		= 480,
+		.hfp		= 48,
+		.hsw		= 32,
+		.hbp		= 80,
+		.vfp		= 3,
+		.vsw		= 4,
+		.vbp		= 7,
+		.pixel_clock	= 23500,
+	},
+	{
+		/* 800 x 600 @ 60 Hz  Reduced blanking VESA CVT 0.48M3-R */
+		.name		= "800x600@60",
+		.x_res		= 800,
+		.y_res		= 600,
+		.hfp		= 48,
+		.hsw		= 32,
+		.hbp		= 80,
+		.vfp		= 3,
+		.vsw		= 4,
+		.vbp		= 11,
+		.pixel_clock	= 35500,
+	},
+	{
+		/* 1024 x 768 @ 60 Hz  Reduced blanking VESA CVT 0.79M3-R */
+		.name		= "1024x768@60",
+		.x_res		= 1024,
+		.y_res		= 768,
+		.hfp		= 48,
+		.hsw		= 32,
+		.hbp		= 80,
+		.vfp		= 3,
+		.vsw		= 4,
+		.vbp		= 15,
+		.pixel_clock	= 56000,
+	},
+	{
+		/* 1280 x 720 @ 60 Hz  Reduced blanking VESA CVT 0.92M9-R */
+		.name		= "1280x720@60",
+		.x_res		= 1280,
+		.y_res		= 720,
+		.hfp		= 48,
+		.hsw		= 32,
+		.hbp		= 80,
+		.vfp		= 3,
+		.vsw		= 5,
+		.vbp		= 13,
+		.pixel_clock	= 64000,
+	},
+	{
+		/* 720 x 480 @ 60 Hz  CEA-861 Format 3 */
+		.name		= "480p60",
+		.x_res		= 720,
+		.y_res		= 480,
+		.hfp		= 16,
+		.hsw		= 62,
+		.hbp		= 60,
+		.vfp		= 9,
+		.vsw		= 6,
+		.vbp		= 30,
+		.pixel_clock	= 27027,
+	},
+	{
+		/* 720 x 576 @ 60 Hz  CEA-861 Format 18 */
+		.name		= "576p50",
+		.x_res		= 720,
+		.y_res		= 576,
+		.hfp		= 12,
+		.hsw		= 64,
+		.hbp		= 68,
+		.vfp		= 5,
+		.vsw		= 5,
+		.vbp		= 39,
+		.pixel_clock	= 27000,
+	},
+	{
+		/* 1280 x 720 @ 50 Hz  CEA-861B Format 19 */
+		.name 		= "720p50",
+		.x_res		= 1280,
+		.y_res		= 720,
+		.hfp		= 440,
+		.hsw		= 40,
+		.hbp		= 220,
+		.vfp		= 20,
+		.vsw		= 5,
+		.vbp		= 5,
+		.pixel_clock	= 74250,
+	},
+	{
+		/* 1280 x 720 @ 60 Hz  CEA-861B Format 4 */
+		.name		= "720p60",
+		.x_res		= 1280,
+		.y_res		= 720,
+		.hfp		= 110,
+		.hsw		= 40,
+		.hbp		= 220,
+		.vfp		= 20,
+		.vsw		= 5,
+		.vbp		= 5,
+		.pixel_clock	= 74250,
+	},
+	{
+		/* 1920 x 1080 @ 24 Hz  CEA-861B Format 32 */
+		.name		= "1080p24",
+		.x_res		= 1920,
+		.y_res		= 1080,
+		.hfp		= 148,
+		.hsw		= 44,
+		.hbp		= 638,
+		.vfp		= 36,
+		.vsw		= 5,
+		.vbp		= 4,
+		.pixel_clock	= 74250,
+	},
+	{
+		/* 1920 x 1080 @ 25 Hz  CEA-861B Format 33 */
+		.name		= "1080p25",
+		.x_res		= 1920,
+		.y_res		= 1080,
+		.hfp		= 148,
+		.hsw		= 44,
+		.hbp		= 528,
+		.vfp		= 36,
+		.vsw		= 5,
+		.vbp		= 4,
+		.pixel_clock	= 74250,
+	},
+	{
+		/* 1920 x 1080 @ 25 Hz  CEA-861B Format 34 */
+		.name		= "1080p30",
+		.x_res		= 1920,
+		.y_res		= 1080,
+		.hfp		= 148,
+		.hsw		= 44,
+		.hbp		= 88,
+		.vfp		= 36,
+		.vsw		= 5,
+		.vbp		= 4,
+		.pixel_clock	= 74250,
+	},
+	{
+        	.name     	= "4.3inch_LCD",
+       		.x_res          = 480,
+        	.y_res          = 272,
+        	.hsw            = 41,           /* hsync_len (4) - 1 */
+        	.hfp            = 2,            /* right_margin (4) - 1 */
+        	.hbp            = 2,            /* left_margin (40) - 1 */
+        	.vsw            = 10,           /* vsync_len (2) - 1 */
+        	.vfp            = 2,            /* lower_margin */
+        	.vbp            = 2,            /* upper_margin (8) - 1 */
+		.pixel_clock	= 9600,
+	},
+        {
+                .name           = "5.6inch_LCD",
+                .x_res          = 640,
+                .y_res          = 480,
+                .hsw            = 5,            /* hsync_len (4) - 1 */
+                .hfp            = 20,           /* right_margin (4) - 1 */
+                .hbp            = 145,          /* left_margin (40) - 1 */
+                .vsw            = 1,            /* vsync_len (2) - 1 */
+                .vfp            = 8,            /* lower_margin */
+                .vbp            = 14,           /* upper_margin (8) - 1 */
+                .pixel_clock    = 26000,
+        },
+        {
+                .name           = "7inch_LCD",
+                .x_res          = 800,
+                .y_res          = 480,
+                .hsw            = 48,	/* hsync_len (4) - 1 */
+                .hfp            = 1,      /* right_margin (4) - 1 */
+                .hbp            = 1,      /* left_margin (40) - 1 */
+                .vsw            = 3,       /* vsync_len (2) - 1 */
+                .vfp            = 12,     /* lower_margin */
+                .vbp            = 25,     /* upper_margin (8) - 1 */
+                .pixel_clock    = 36000,
+        },
+        {
+                .name           = "10.4inch_LCD",
+                .x_res          = 800,
+                .y_res          = 600,
+                .hsw            = 48,   /* hsync_len (4) - 1 */
+                .hfp            = 1,      /* right_margin (4) - 1 */
+                .hbp            = 1,      /* left_margin (40) - 1 */
+                .vsw            = 3,       /* vsync_len (2) - 1 */
+                .vfp            = 12,     /* lower_margin */
+                .vbp            = 25,     /* upper_margin (8) - 1 */
+                .pixel_clock    = 36000,
+        },
+	{
+                .name           = "VGA",
+                .x_res          = 1024,
+                .y_res          = 768,
+                .hsw            = 53,     /* hsync_len (4) - 1 */
+                .hfp            = 18,      /* right_margin (4) - 1 */
+                .hbp            = 248,      /* left_margin (40) - 1 */
+                .vsw            = 6,       /* vsync_len (2) - 1 */
+                .vfp            = 3,     /* lower_margin */
+                .vbp            = 29,     /* upper_margin (8) - 1 */
+                .pixel_clock    = 72000,
+	},
+
+};
+
 #ifdef DEBUG
 static void fill_fb(struct fb_info *fbi)
 {
@@ -644,14 +867,14 @@
 		/* setup DSS's view to always 0 degrees */
 		data_start_p = ofbi->region.vrfb.paddr[0];
 		data_start_v = ofbi->region.vrfb.vaddr[0];
-		if (ofbi->rotation == FB_ROTATE_CW ||
-				ofbi->rotation == FB_ROTATE_CCW) {
-			offset = ((var->xoffset * VRFB_WIDTH +
-				var->yoffset) * var->bits_per_pixel) >> 3;
-		} else {
-			offset = ((var->yoffset * VRFB_WIDTH +
-				var->xoffset) * var->bits_per_pixel) >> 3;
-		}
+                 if (ofbi->rotation == FB_ROTATE_CW ||
+                                 ofbi->rotation == FB_ROTATE_CCW) {
+                         offset = ((var->xoffset * VRFB_WIDTH +
+                                 var->yoffset) * var->bits_per_pixel) >> 3;
+                 } else {
+                         offset = ((var->yoffset * VRFB_WIDTH +
+                                 var->xoffset) * var->bits_per_pixel) >> 3;
+                 }
 	} else {
 		data_start_p = omapfb_get_region_paddr(ofbi);
 		data_start_v = omapfb_get_region_vaddr(ofbi);
@@ -1624,6 +1847,7 @@
 		goto cleanup;
 	}
 
+#if 0
 	if (def_mode && strlen(def_mode) > 0)
 	{
 		struct omap_video_timings timings;
@@ -1636,6 +1860,28 @@
 			def_display->panel->bpp = bpp;
 		}
 	}
+#else
+        if (video_mode.name) {
+                pr_info("omapfb: using mode %s\n", video_mode.name);
+		struct omap_video_timings timings;
+
+		timings.x_res = video_mode.x_res;
+		timings.y_res = video_mode.y_res;
+		timings.pixel_clock = video_mode.pixel_clock;
+		timings.hsw = video_mode.hsw;
+                timings.hfp = video_mode.hfp;
+                timings.hbp = video_mode.hbp;
+		timings.vsw = video_mode.vsw;
+                timings.vfp = video_mode.vfp;
+                timings.vbp = video_mode.vbp;
+
+                if (def_display->set_timings)
+                	def_display->set_timings(def_display, &timings);
+
+		def_display->panel->bpp = 16;
+		def_display->panel->config = OMAP_DSS_LCD_TFT | OMAP_DSS_LCD_IVS | OMAP_DSS_LCD_IHS;
+        }
+#endif
 
 	r = omapfb_create_framebuffers(fbdev);
 	if (r)
@@ -1733,10 +1979,58 @@
 	},
 };
 
+static void __init omapfb_find_mode(char *name, struct video_mode *vmode)
+{
+	int i;
+
+	for (i = 0; i < sizeof(video_modes)/sizeof(video_modes[0]); i++)
+		if (!strcmp(name, video_modes[i].name)) {
+			*vmode = video_modes[i];
+			break;
+		}
+}
+
+#ifndef MODULE
+/* Process kernel command line parameters */
+static int __init omapfb_setup(char *options)
+{
+	char *this_opt = NULL;
+	int r = 0;
+
+	pr_debug("omapfb: options %s\n", options);
+
+	if (!options || !*options)
+		return 0;
+
+	while (!r && (this_opt = strsep(&options, ",")) != NULL) {
+		if (!strncmp(this_opt, "mode:", 5))
+			strncpy(def_mode, this_opt + 5, sizeof(def_mode));
+		else {
+			pr_debug("omapfb: invalid option\n");
+			r = -1;
+		}
+	}
+
+	return r;
+}
+#endif
+
 static int __init omapfb_init(void)
 {
 	DBG("omapfb_init\n");
 
+#ifndef MODULE
+        char *option;
+
+        if (fb_get_options("omapfb", &option))
+                return -ENODEV;
+
+        omapfb_setup(option);
+#endif
+
+        omapfb_find_mode(def_mode[0]? def_mode : "4.3inch_LCD",
+                         &video_mode);
+
 	if (platform_driver_register(&omapfb_driver)) {
 		printk(KERN_ERR "failed to register omapfb driver\n");
 		return -ENODEV;
diff -ruN linux-02.01.03.11-org/include/linux/mmc/core.h linux-02.01.03.11-new/include/linux/mmc/core.h
--- linux-02.01.03.11-org/include/linux/mmc/core.h	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/include/linux/mmc/core.h	2010-01-18 20:35:33.000000000 +0800
@@ -151,6 +151,4 @@
 	__mmc_claim_host(host, NULL);
 }
 
-extern u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max);
-
 #endif
diff -ruN linux-02.01.03.11-org/include/linux/mmc/host.h linux-02.01.03.11-new/include/linux/mmc/host.h
--- linux-02.01.03.11-org/include/linux/mmc/host.h	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/include/linux/mmc/host.h	2010-01-18 20:35:33.000000000 +0800
@@ -41,7 +41,6 @@
 
 #define MMC_BUS_WIDTH_1		0
 #define MMC_BUS_WIDTH_4		2
-#define MMC_BUS_WIDTH_8		3
 
 	unsigned char	timing;			/* timing specification used */
 
@@ -117,7 +116,6 @@
 #define MMC_CAP_SDIO_IRQ	(1 << 3)	/* Can signal pending SDIO IRQs */
 #define MMC_CAP_SPI		(1 << 4)	/* Talks only SPI protocols */
 #define MMC_CAP_NEEDS_POLL	(1 << 5)	/* Needs polling for card-detection */
-#define MMC_CAP_8_BIT_DATA	(1 << 6)	/* Can the host do 8 bit transfers */
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
diff -ruN linux-02.01.03.11-org/include/linux/w1-gpio.h linux-02.01.03.11-new/include/linux/w1-gpio.h
--- linux-02.01.03.11-org/include/linux/w1-gpio.h	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/include/linux/w1-gpio.h	2010-01-18 20:23:09.000000000 +0800
@@ -16,7 +16,8 @@
  * @is_open_drain: GPIO pin is configured as open drain
  */
 struct w1_gpio_platform_data {
-	unsigned int pin;
+	unsigned int pin_in;
+	unsigned int pin_out;
 	unsigned int is_open_drain:1;
 };
 
diff -ruN linux-02.01.03.11-org/jilu linux-02.01.03.11-new/jilu
--- linux-02.01.03.11-org/jilu	1970-01-01 08:00:00.000000000 +0800
+++ linux-02.01.03.11-new/jilu	2010-01-20 10:50:56.000000000 +0800
@@ -0,0 +1 @@
+网卡已全部替换回去，还不能用，其他能用
diff -ruN linux-02.01.03.11-org/Makefile linux-02.01.03.11-new/Makefile
--- linux-02.01.03.11-org/Makefile	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/Makefile	2010-01-18 19:24:44.000000000 +0800
@@ -196,7 +196,7 @@
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
 ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?= arm-linux-
+CROSS_COMPILE	= arm-none-linux-gnueabi-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
diff -ruN linux-02.01.03.11-org/sound/soc/codecs/twl4030.c linux-02.01.03.11-new/sound/soc/codecs/twl4030.c
--- linux-02.01.03.11-org/sound/soc/codecs/twl4030.c	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/sound/soc/codecs/twl4030.c	2010-01-20 09:26:41.000000000 +0800
@@ -42,13 +42,13 @@
  */
 static const u8 twl4030_reg[TWL4030_CACHEREGNUM] = {
 	0x00, /* this register not used		*/
-	0x91, /* REG_CODEC_MODE		(0x1)	*/
-	0xc3, /* REG_OPTION		(0x2)	*/
+	/*0x91*/0x93, /* REG_CODEC_MODE		(0x1)	*/
+	/*0xc3*/0xc1, /* REG_OPTION		(0x2)	*/
 	0x00, /* REG_UNKNOWN		(0x3)	*/
-	0x00, /* REG_MICBIAS_CTL	(0x4)	*/
-	0x20, /* REG_ANAMICL		(0x5)	*/
-	0x00, /* REG_ANAMICR		(0x6)	*/
-	0x00, /* REG_AVADC_CTL		(0x7)	*/
+	/*0x00*/0x01, /* REG_MICBIAS_CTL	(0x4)	*/
+	/*0x24*/0x31, /* REG_ANAMICL		(0x5)	*/
+	/*0x14*/0x00, /* REG_ANAMICR		(0x6)	*/
+	/*0x0a*/0x08, /* REG_AVADC_CTL		(0x7)	*/
 	0x00, /* REG_ADCMICSEL		(0x8)	*/
 	0x00, /* REG_DIGMIXING		(0x9)	*/
 	0x0c, /* REG_ATXL1PGA		(0xA)	*/
@@ -78,8 +78,8 @@
 	0x24, /* REG_HS_SEL		(0x22)	*/
 	0x0a, /* REG_HS_GAIN_SET	(0x23)	*/
 	0x00, /* REG_HS_POPN_SET	(0x24)	*/
-	0x00, /* REG_PREDL_CTL		(0x25)	*/
-	0x00, /* REG_PREDR_CTL		(0x26)	*/
+	0x24, /* REG_PREDL_CTL		(0x25)	*/
+	0x24, /* REG_PREDR_CTL		(0x26)	*/
 	0x00, /* REG_PRECKL_CTL		(0x27)	*/
 	0x00, /* REG_PRECKR_CTL		(0x28)	*/
 	0x00, /* REG_HFL_CTL		(0x29)	*/
@@ -88,7 +88,7 @@
 	0x00, /* REG_ALC_SET1		(0x2C)	*/
 	0x00, /* REG_ALC_SET2		(0x2D)	*/
 	0x00, /* REG_BOOST_CTL		(0x2E)	*/
-	0x00, /* REG_SOFTVOL_CTL	(0x2F)	*/
+	/*0x00*/0x01, /* REG_SOFTVOL_CTL	(0x2F)	*/
 	0x00, /* REG_DTMF_FREQSEL	(0x30)	*/
 	0x00, /* REG_DTMF_TONEXT1H	(0x31)	*/
 	0x00, /* REG_DTMF_TONEXT1L	(0x32)	*/
@@ -113,7 +113,7 @@
 	0x00, /* REG_VIBRA_CTL		(0x45)	*/
 	0x00, /* REG_VIBRA_SET		(0x46)	*/
 	0x00, /* REG_VIBRA_PWM_SET	(0x47)	*/
-	0x00, /* REG_ANAMIC_GAIN	(0x48)	*/
+	/*0x00*/0x24, /* REG_ANAMIC_GAIN	(0x48)	*/
 	0x00, /* REG_MISC_SET_2		(0x49)	*/
 	0x00, /* REG_SW_SHADOW		(0x4A)	- Shadow, non HW register */
 };
diff -ruN linux-02.01.03.11-org/sound/soc/omap/Kconfig linux-02.01.03.11-new/sound/soc/omap/Kconfig
--- linux-02.01.03.11-org/sound/soc/omap/Kconfig	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/sound/soc/omap/Kconfig	2010-01-20 09:37:58.000000000 +0800
@@ -47,6 +47,14 @@
 	help
 	  Say Y if you want to add support for SoC audio on the omap3evm board.
 
+config SND_OMAP_SOC_OMAP3_DEVKIT8000
+        tristate "SoC Audio support for OMAP3 DevKit8000 board"
+        depends on TWL4030_CORE && SND_OMAP_SOC && MACH_OMAP3_DEVKIT8000
+        select SND_OMAP_SOC_MCBSP
+        select SND_SOC_TWL4030
+        help
+          Say Y if you want to add support for SoC audio on the omap3_devkit8000 board.
+
 config SND_OMAP_SOC_SDP3430
 	tristate "SoC Audio support for Texas Instruments SDP3430"
 	depends on TWL4030_CORE && SND_OMAP_SOC && MACH_OMAP_3430SDP
diff -ruN linux-02.01.03.11-org/sound/soc/omap/Makefile linux-02.01.03.11-new/sound/soc/omap/Makefile
--- linux-02.01.03.11-org/sound/soc/omap/Makefile	2009-09-07 20:29:13.000000000 +0800
+++ linux-02.01.03.11-new/sound/soc/omap/Makefile	2010-01-20 09:36:35.000000000 +0800
@@ -11,6 +11,7 @@
 snd-soc-overo-objs := overo.o
 snd-soc-omap2evm-objs := omap2evm.o
 snd-soc-omap3evm-objs := omap3evm.o
+snd-soc-omap3_devkit8000-objs := omap3_devkit8000.o
 snd-soc-sdp3430-objs := sdp3430.o
 snd-soc-omap3pandora-objs := omap3pandora.o
 
@@ -19,5 +20,6 @@
 obj-$(CONFIG_SND_OMAP_SOC_OVERO) += snd-soc-overo.o
 obj-$(CONFIG_MACH_OMAP2EVM) += snd-soc-omap2evm.o
 obj-$(CONFIG_MACH_OMAP3EVM) += snd-soc-omap3evm.o
+obj-$(CONFIG_SND_OMAP_SOC_OMAP3_DEVKIT8000) += snd-soc-omap3_devkit8000.o
 obj-$(CONFIG_SND_OMAP_SOC_SDP3430) += snd-soc-sdp3430.o
 obj-$(CONFIG_SND_OMAP_SOC_OMAP3_PANDORA) += snd-soc-omap3pandora.o
diff -ruN linux-02.01.03.11-org/sound/soc/omap/omap3_devkit8000.c linux-02.01.03.11-new/sound/soc/omap/omap3_devkit8000.c
--- linux-02.01.03.11-org/sound/soc/omap/omap3_devkit8000.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-02.01.03.11-new/sound/soc/omap/omap3_devkit8000.c	2010-01-19 16:04:21.000000000 +0800
@@ -0,0 +1,154 @@
+/*
+ * omap3evm.c  -- ALSA SoC support for OMAP3 EVM
+ *
+ * Author: Anuj Aggarwal <anuj.aggarwal@ti.com>
+ *
+ * Based on sound/soc/omap/beagle.c by Steve Sakoman
+ *
+ * Copyright (C) 2008 Texas Instruments, Incorporated
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/mcbsp.h>
+
+#include "omap-mcbsp.h"
+#include "omap-pcm.h"
+#include "../codecs/twl4030.h"
+
+static int omap3evm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	int ret;
+
+	/* Set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai,
+				  SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_NB_NF |
+				  SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0) {
+		printk(KERN_ERR "can't set codec DAI configuration\n");
+		return ret;
+	}
+
+	/* Set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai,
+				  SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_NB_NF |
+				  SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0) {
+		printk(KERN_ERR "can't set cpu DAI configuration\n");
+		return ret;
+	}
+
+	/* Set the codec system clock for DAC and ADC */
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, 26000000,
+				     SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		printk(KERN_ERR "can't set codec system clock\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops omap3evm_ops = {
+	.hw_params = omap3evm_hw_params,
+};
+
+/* Digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link omap3evm_dai = {
+	.name = "TWL4030",
+	.stream_name = "TWL4030",
+	.cpu_dai = &omap_mcbsp_dai[0],
+	.codec_dai = &twl4030_dai[TWL4030_DAI_HIFI],
+	.ops = &omap3evm_ops,
+};
+
+/* Audio machine driver */
+static struct snd_soc_card snd_soc_omap3evm = {
+	.name = "omap3evm",
+	.platform = &omap_soc_platform,
+	.dai_link = &omap3evm_dai,
+	.num_links = 1,
+};
+
+/* twl4030 setup */
+static struct twl4030_setup_data twl4030_setup = {
+	.ramp_delay_value = 4,
+	.sysclk = 26000,
+};
+
+/* Audio subsystem */
+static struct snd_soc_device omap3evm_snd_devdata = {
+	.card = &snd_soc_omap3evm,
+	.codec_dev = &soc_codec_dev_twl4030,
+	.codec_data = &twl4030_setup,
+};
+
+static struct platform_device *omap3evm_snd_device;
+
+static int __init omap3evm_soc_init(void)
+{
+	int ret;
+#if 0
+	if (!machine_is_omap3evm()) {
+		pr_err("Not OMAP3 EVM!\n");
+		return -ENODEV;
+	}
+	pr_info("OMAP3 EVM SoC init\n");
+#endif
+	omap3evm_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!omap3evm_snd_device) {
+		printk(KERN_ERR "Platform device allocation failed\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(omap3evm_snd_device, &omap3evm_snd_devdata);
+	omap3evm_snd_devdata.dev = &omap3evm_snd_device->dev;
+	*(unsigned int *)omap3evm_dai.cpu_dai->private_data = 1; /* McBSP2 */
+
+	ret = platform_device_add(omap3evm_snd_device);
+	if (ret)
+		goto err1;
+
+	return 0;
+
+err1:
+	printk(KERN_ERR "Unable to add platform device\n");
+	platform_device_put(omap3evm_snd_device);
+
+	return ret;
+}
+
+static void __exit omap3evm_soc_exit(void)
+{
+	platform_device_unregister(omap3evm_snd_device);
+}
+
+module_init(omap3evm_soc_init);
+module_exit(omap3evm_soc_exit);
+
+MODULE_AUTHOR("Anuj Aggarwal <anuj.aggarwal@ti.com>");
+MODULE_DESCRIPTION("ALSA SoC OMAP3 EVM");
+MODULE_LICENSE("GPL");
diff -ruN linux-02.01.03.11-org/sound/soc/omap/omap3_sbc8100.c linux-02.01.03.11-new/sound/soc/omap/omap3_sbc8100.c
--- linux-02.01.03.11-org/sound/soc/omap/omap3_sbc8100.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-02.01.03.11-new/sound/soc/omap/omap3_sbc8100.c	2010-01-19 16:03:56.000000000 +0800
@@ -0,0 +1,154 @@
+/*
+ * omap3evm.c  -- ALSA SoC support for OMAP3 EVM
+ *
+ * Author: Anuj Aggarwal <anuj.aggarwal@ti.com>
+ *
+ * Based on sound/soc/omap/beagle.c by Steve Sakoman
+ *
+ * Copyright (C) 2008 Texas Instruments, Incorporated
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
+ * whether express or implied; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/mcbsp.h>
+
+#include "omap-mcbsp.h"
+#include "omap-pcm.h"
+#include "../codecs/twl4030.h"
+
+static int omap3evm_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	int ret;
+
+	/* Set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai,
+				  SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_NB_NF |
+				  SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0) {
+		printk(KERN_ERR "can't set codec DAI configuration\n");
+		return ret;
+	}
+
+	/* Set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai,
+				  SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_NB_NF |
+				  SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0) {
+		printk(KERN_ERR "can't set cpu DAI configuration\n");
+		return ret;
+	}
+
+	/* Set the codec system clock for DAC and ADC */
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, 26000000,
+				     SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		printk(KERN_ERR "can't set codec system clock\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops omap3evm_ops = {
+	.hw_params = omap3evm_hw_params,
+};
+
+/* Digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link omap3evm_dai = {
+	.name = "TWL4030",
+	.stream_name = "TWL4030",
+	.cpu_dai = &omap_mcbsp_dai[0],
+	.codec_dai = &twl4030_dai[TWL4030_DAI_HIFI],
+	.ops = &omap3evm_ops,
+};
+
+/* Audio machine driver */
+static struct snd_soc_card snd_soc_omap3evm = {
+	.name = "omap3evm",
+	.platform = &omap_soc_platform,
+	.dai_link = &omap3evm_dai,
+	.num_links = 1,
+};
+
+/* twl4030 setup */
+static struct twl4030_setup_data twl4030_setup = {
+	.ramp_delay_value = 4,
+	.sysclk = 26000,
+};
+
+/* Audio subsystem */
+static struct snd_soc_device omap3evm_snd_devdata = {
+	.card = &snd_soc_omap3evm,
+	.codec_dev = &soc_codec_dev_twl4030,
+	.codec_data = &twl4030_setup,
+};
+
+static struct platform_device *omap3evm_snd_device;
+
+static int __init omap3evm_soc_init(void)
+{
+	int ret;
+#if 0
+	if (!machine_is_omap3evm()) {
+		pr_err("Not OMAP3 EVM!\n");
+		return -ENODEV;
+	}
+	pr_info("OMAP3 EVM SoC init\n");
+#endif
+	omap3evm_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!omap3evm_snd_device) {
+		printk(KERN_ERR "Platform device allocation failed\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(omap3evm_snd_device, &omap3evm_snd_devdata);
+	omap3evm_snd_devdata.dev = &omap3evm_snd_device->dev;
+	*(unsigned int *)omap3evm_dai.cpu_dai->private_data = 1; /* McBSP2 */
+
+	ret = platform_device_add(omap3evm_snd_device);
+	if (ret)
+		goto err1;
+
+	return 0;
+
+err1:
+	printk(KERN_ERR "Unable to add platform device\n");
+	platform_device_put(omap3evm_snd_device);
+
+	return ret;
+}
+
+static void __exit omap3evm_soc_exit(void)
+{
+	platform_device_unregister(omap3evm_snd_device);
+}
+
+module_init(omap3evm_soc_init);
+module_exit(omap3evm_soc_exit);
+
+MODULE_AUTHOR("Anuj Aggarwal <anuj.aggarwal@ti.com>");
+MODULE_DESCRIPTION("ALSA SoC OMAP3 EVM");
+MODULE_LICENSE("GPL");
